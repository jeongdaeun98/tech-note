- 트랜잭션 정의
    
    DB 상태를 변경시키기 위해 수행하는 논리적인 작업 단위라고 할 수 있다. 
    
    하나의 작업을 처리하기 위해 필요한 DB 연산을 모아놓은 것.
    
    - 트랜잭션은 Exclusive Lock 을 발생시키에 Lock과 유사한 기능을 하지만 Lock은 여러 세션이 자원을 동시에 요청할 때 간섭으로 문제가 발생하지 않도록 한 시점에 하나의 세션만 변경할 수 있게 실행 순서를 제어하기 위한 기능이고,
    - 트랜잭션은 데이터 정합성을 보장하기 위해, 논리적인 작업의 쿼리 개수와 관계 없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장
    - 주의사항
        - 최소한의 코드에 적용하는 것이 좋음
        - DB 커넥션의 수는 제한적 -> 커넥션이 부족해 대기할 수 있음
        - 트랜잭션 범위를 작게 나눠서 적용해야 DB에 오버헤드가 줄음
- 트랜잭션 특성 -ACID
    
    Atomicity(원자성)
    
    : 트랜잭션 내 실행한 작업들은 하나의 작업인 것 처럼 모두 성공하거나 모두 실패해야 함. 하나의 트랜잭션에서 일부 연산만 실행되는 경우는 없음.
    
    ex) update후 select한 뒤, Insert 작업이 일어나는 작업을 트랜잭션 단위로 설정했으나, insert 작업만 일어나지 않는다.
    
    Consistency(일관성)
    
    : 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 함. DB에서 정한 무결성 제약 조건을 항상 만족해야 함.
    
    ex) 은행 송금 시, 트랜잭션 수행 이전 송금자와 수금자의 잔액 합이 수행 후에 달라지거나, 잔액을 나타내는 자료형이 정수형에서 문자열로 바뀌는 모순이 발생해서는 안된다.
    
    Isolation(격리성, 독립성)
    
    : 트랜잭션은 다른 트랜잭션에 간섭을 주거나 받지 않고 독립적으로 수행되어야 함.
    
    둘 이상의 트랜잭션이 병행 실행될 경우, 현재 실행 중인 트랜잭션이 완료되기 전 현재 트랜잭션이 생성한 중간 연산 결과를 다른 트랜잭션이 접근해서는 안된다.
    
    Durability(지속성)
    
    : 트랜잭션이 성공적으로 완료되었다면, 그 결과는 영구적으로 반영되어야 한다.
    
    시스템 장애가 발생하더라도 결과는 DB에 그대로 남아있어야 하며, 지속성을 보장하기 위해 DB로그를 남긴다던지, 복제 서버를 만들어놓는다던지의 복구가 필요하다.
    
- DB 세션
    
    사용자는 DB서버에 연결 요청 후, 커넥션을 맺음.
    
    그리고 DB 서버는 내부에 세션을 만들고, 커넥션을 통한 모든 요청은 세션을 통해 실행.
    
    세션은 트랜잭션을 시작하고, 커밋 혹은 롤백을 통해 트랜잭션을 종료함.
    
    이후 새로운 트랜잭션을 다시 시작할 수 있음.
    
    사용자가 커넥션을 닫거나, DB 관리자가 세션을 강제 종료하면 세션은 종료됨.
    
- commit and rollback
    
    트랜잭션을 사용하면 commit과 rollback을 통해 정상적인 작업이 가능하도록 할 수 있음.
    
    작업 중 하나라도 실패 해서 거래 이전으로 돌리는 것을 롤백, 모든 작업이 정상적으로 성공하여 데이터베이스에 정상 반영하는 것을 커밋이라 한다.
    
- 스키마와 테이블의 차이
    
    **스키마**
    
    - 데이터베이스의 데이터 구조에 대한 공식적인 설명 -> 테이블, 열, 데이터 유형, 인덱스 등의 정의를 포함
    
    **테이블**
    
    - 행과 열로 구성된 데이터 집합
- 동시성 제어
    
    DBMS에 여러 세션이 간섭하게 되면 트랜잭션 간에 충돌이 발생하는데, 충돌이 발생하지 않게 트랜잭션을 순차적으로 처리할 수 있도록 제어하는 것.
    
    - 낙관적 동시성 제어
        - 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라 가정
        - 데이터 읽는 시점에 lock을 걸지 않는 대신 수정 시점에 값이 변경됐는지 검사
    - 비관적 동시성 제어
        - 사용자들이 같은 데이터를 동시에 수정할거라 가정
        - 데이터 읽는 시점에 lock 걸고, 트랜잭션 완료될 때까지 유지
        - 시스템 동시성을 심각하게 떨어뜨릴 수 있어, wait 혹은 nowait 옵션과 함께 사용해야 함
            - NOWAIT : 쿼리를 실행하며, lock이 걸린 부분이 있다면, 기다리지 않고 실패
            - wait:  설정된 innodb_lock_wait_timeout 만큼 기다리고 초과되면 실패
- MVCC
    - 동시 접근을 허용하는 DB에서 동시성을 제어하기 위해 사용하는 방법
    - 데이터에 접근하는 사용자는 접근한 시점에 Snapshot(가장 최근 커밋된 데이터)를 읽음. commit 될 때까지 변경은 다른 사용자가 볼 수 없다.
        - 따라서 MVCC는 추가적인 저장공간을 많이 사용함.
        - 사용자가 데이터를 업데이트 하면 이전의 데이터를 덮어 씌우는 것이 아니라 새로운 버전의 데이터를 이전 버전의 데이터와 비교해서 변경 대상의 이전 버전 값을 UNDO에 생성
    - MVCC는 데이터 처리할 때 block 하지 않아 성능이 빠름.
    - MVCC는 테이블에 선반영하고, 기존 데이터는 언두로그에 백업해둔다. 롤백 필요할 경우 언두 로그 참고해 롤백함.
    - 그러나 하나의 데이터에 대해 여러 버전의 데이터를 활용하여, 버전간 충돌로 인해 데이터 정합성 문제가 발생할 수 있어 어플리케이션 레벨에서 해결해야 함.
    1. MVCC를 통해 트랜잭션이 롤백된 경우, 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간 접근할 수 있는 데이터 제어 가능.
        1. 각각 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장하므로 제어 가능함.
    2. 해당 데이터라 불필요하다고 판단되는 시점에 주기적으로 백그라운드 스레드를 통해 삭제
    
    **문제점**
    
    - UNDO BLOCK I/O, CR 블록 캐싱과 같은 작업의 오버헤드가 발생
    
    - CURRENT BLOCK : 카밋이 완료된 블럭
    
    - UNDO BLOCK : 커밋 이전 데이터 블럭
    
    - CR(Consistent read) 블록 : 조회시점(SCN)의 UNDO 블록 복사
    
- MVCC - 언두 로그,리두 로그
    - UNDO log
    - : 트랜잭션과 격리 수준을 보장하기 위해 백업해둔 변경 전 데이터
        - 트랜잭션이 롤백되면 변경된 데이터를 백업된 이전 버전으로 복구
        - 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터 조회 시 격리 수준에 맞는 데이터 변환
    - 언두 영역에는 변경 전의 값을 백업해두다가 커밋되면 현 상태를 유지, 롤백되면 백업 데이터로 복구하는데, 이러한 동작 방식으로 인해 아래와 같은 상황들엔 적합하지 않다.
        - 대량의 데이터 변경 및 삭제 : 변경 전 데이터를 언두 로그에 기록하고, 커밋 전까지 계속 유지하므로 저장 공간을 그만큼 차지하게 되어 문제가 된다.
        - 트랜잭션 오래 유지하는 경우: 해당 트랜잭션이 커밋 혹은 롤백으로 완료 될 때까지 언두 로그를 쌓는데, 시간이 지나 롤백을 하게 된다면, 변경 전 레코드를 찾아야하므로 쿼리 성능이 떨어진다.
    - REDO log
    - : 트랜잭션의 Durability를 지키기 위한 시스템이다. 데이터 변경 내용을 리두 로그로 기록하고, 비정상적으로 종료되었을 경우 일관된 데이터를 가질 수 있도록 도와준다.
        - 커밋됐지만 데이터 파일에 기록되지 않은 데이터
        - 롤백 됐지만 데이터 파일에 기록된 데이터
    - 리두 로그는 버퍼 공간이 존재한다. 매번 디스크에 바로 기록하면 랜덤 I/O 때문에 성능이 떨어지므로, 일정 주기로 버퍼 내용을 디스크에 동기화하도록 되어있다.
- 버퍼풀
    - 데이터를 임시 저장하기 위한 메모리 공간, 디스크에 저장된 테이블과 인덱스 정보를 캐시해두는 공간
        - 캐싱을 통한 읽기 성능 향상
        - 쓰기 지연을 통한 쓰기 성능 향상
    - 쓰기 작업을 매번 수행하면 랜덤 I/O가 매번 발생하지만, 버퍼 풀을 사용하면 일괄 처리 하므로 디스크 I/O를 줄여 성능을 높일 수 있음.
    - 서버가 셧다운 되기 직전 버퍼 풀 백업 후 자동으로 복구해야함.
- 랜덤 I/O, 순차 I/O
    - 랜덤 I/O
        - 데이터가 물리적으로 불연속적으로 있어 디스크 헤더를 이동시킨 후 데이터를 읽는 것
        - 디스크 성능은 랜덤 I/O를 줄이는 것임. 즉, 디스크 헤더의 이동 없이 얼마나 많은 데이터를 순차적으로 저장하느냐에 달렸음.
    - 순차 I/O
        - 읽어야 하는 데이터가 연속적으로 있어 쭉 읽기만 하는 것
- db lock
    
    비관적 동시성 제어를 위한 대표적인 방법으로 lock이 있음. 락을 해제하는 방법은 commit과 rollback임.
    
    - 공유락: 읽기 잠금
    - 배타락: 쓰기 잠금
    - 1번 트랜잭션이 공유락을 가져간 경우
        - 2번 트랜잭션이 동일한 데이터를 읽는 경우, 데이터가 일관되므로 2번 트랜잭션이 또 다른 공유락을 가져가면서 동시에 처리
        - 2번 트랜잭션이 동일한 데이터를 쓰는 경우, 1번 트랜잭션과 데이터가 달라질 수 있어 1번 트랜잭션 종료까지 대기
    - 1번 트랜잭션이 배타락을 가져간 경우
        - 2번 트랜잭션이 동일한 데이터를 읽는 경우, 1번 트랜잭션이 데이터 변경할 수 있으므로 대기
        - 2번 트랜잭션이 동일한 데이터 쓰는 경우, 1번 트랜잭션이 데이터 변경할 수 있으므로 대기
    - 문제점
        - 락이 걸린 경우, 트랜잭션을 처리하지 못하는 경우가 있고, lock을 더 오래 유지하거나 테이블 레벨의 lock을 사용하게 되는 경우 동시성 저하 발생
- 인덱스 정의
    - 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터 베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
    - 인덱스를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 full scan, 즉 전체를 탐색해야 한다.
    - Insert,update,delete 작업이 수행될 때마다 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있음.
    - 인덱스 사용하면 좋은 케이스
        - 규모 작지 않은 테이블
        - insert, update, delete이 자주 발생하지 않는 컬럼
        - join이나 where, order by에 자주 사용되는 컬럼
        - 데이터 중복도가 낮은 컬럼
- 인덱스 장단점
    - 장점
        - 테이블 조회 속도와 그에 따른 성능 향상
        - 전반적인 시스템 부하 줄임
    - 단점
        - 인덱스 관리하기 위해 DB의 약 10%에 해당하는 저장 공간 필요.
        - 인덱스를 관리하기 위해 추가 작업 필요
        - 인덱스는 update delete 연산 시, 기존의 인덱스를 삭제하지 않고, 사용하지 않음 처리를 해주는데, 해당 연산이 빈번한 속성에 인덱스 걸게 되면, 실제 데이터에 비해 인덱스 크기가 비대해져 성능 저하
- Clustered Index vs Non Clustered Index
    - Clustered Index

         ![Untitled (11)](https://github.com/uneap/tech-note/assets/25525648/07319ef6-1ae5-489a-af13-23eb64b6bc9a)

        
        - 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 index와 데이터가 쌍을 이룸.
        - 데이터가 테이블에 물리적으로 정렬 후, 저장 순서를 정의
            - 물리적으로 정렬되어, 검색 속도는 non-clustered index 보다 빠름.
        - 정렬된 테이블을 조회하므로, 검색 속도를 향상시키지만, update, delete, insert 시 또 다시 정렬해야 해서 비용 소모가 많다.
        - 특정 컬럼을 기준으로 데이터를 정렬시키는데, 정렬 기준으로 오직 하나의 컬럼만을 선택할 수 있음.
            - 따라서 인덱스를 달았을 때 가장 효율적일 거 같은 컬럼을 클러스터 형 인덱스로 지정
        - PK 설정 시, PK 기준으로 자료가 정렬된다.
    - Non Clustered Index
        
        ![Untitled (12)](https://github.com/uneap/tech-note/assets/25525648/15009d1c-207d-42db-a99e-76ad27f67197)

        
        - 루트 페이지, 리프 페이지, 데이터 페이지로 구성되어있다.
        - 물리적으로 데이터를 정렬하지 않은 상태로 데이터 페이지가 구성되며, 별도 장소에 인덱스 페이지를 구성함.
        - 인덱스 페이지는 키 값과 위치 포인터(RID)로 구성된다.
        - 검색하고자 하는 데이터 키값을 루트 페이지에서 비교해서 리프 페이지 번호를 찾고, 리프 페이지에서 RID 정보로 실제 데이터의 위치로 이동함.
        - clustered index보다 검색 속도 느리지만, update,delete,insert 는 더 빠름.
        - 인덱스는 테이블 당 여러개 존재 가능하다. (그러나 카디널리티가 낮은 컬럼으로 설정 할 경우, 성능 저하)
- 낙관적 락, 비관적 락
    
    **낙관적 락**
    
    - 충돌이 거의 발생하지 않은 것이라 가정, 충돌이 발생한 경우에 대비하는 방식
    - 트랜잭션 커밋 시점에 충돌을 알 수 있음.
    - DB 레벨에서 동시성 처리하는 것이 아닌 어플리케이션 레벨에서 처리함.
    - 리소스 경쟁이 적고 락으로 인한 성능 저하가 적다
    - 충돌 발생 시 처리해야 할 외부 요인이 존재한다.
    
    **비관적 락**
    
    - 충돌 발생할 것이라 가정하고 우선 DB에 lock을 거는 방식
    - 충돌 발생을 미연에 방지하고 데이터 일관성을 유지할 수 있다.
    - 동시 처리 성능 저하 및 교착 상태(dead lock) 발생할 가능성이 있다.
- 즉시 로딩, 지연 로딩
    
    member와 Team이 manyToOne으로 매핑되어있다고 가정한다. 
    
    **지연로딩**
    
    비즈니스 로직에서 멤버 로직만 사용하는데 매번 team을 조회한다면 손해이다. 따라서 지연 로딩을 사용하여 프록시로 조회하는 방법으로 해결했다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/a6a01aba-ca0d-453a-898a-49153f313ca5/Untitled.png)
    
    - 로딩 되는 시점에 lazy 로딩 설정이 되어있는 Team 엔티티는 프록시 객체로 가져온다.
    - 실제 객체 사용 시점에 DB에 쿼리한다.
        - getTeam()으로 team을 조회하면 프록시 객체가 조회 된다.
        - getTeam().getXXX()로 팀 필드에 접근할 때, 쿼리한다.
        
        ```
        Hibernate:
            select
                member0_.id as id1_4_0_,
                member0_.createdBy as createdB2_4_0_,
                member0_.createdDate as createdD3_4_0_,
                member0_.lastModifiedBy as lastModi4_4_0_,
                member0_.lastModifiedDate as lastModi5_4_0_,
                member0_.age as age6_4_0_,
                member0_.description as descript7_4_0_,
                member0_.locker_id as locker_10_4_0_,
                member0_.roleType as roleType8_4_0_,
                member0_.team_id as team_id11_4_0_,
                member0_.name as name9_4_0_,
                locker1_.id as id1_3_1_,
                locker1_.name as name2_3_1_
            from
                Member member0_
            left outer join
                Locker locker1_
                    on member0_.locker_id=locker1_.id
            where
                member0_.id=?
        
        class hello.jpa.Team$HibernateProxy$z4JtUeLD  // 프록시 객체
        
        Hibernate:
            select
                team0_.id as id1_8_0_,
                team0_.createdBy as createdB2_8_0_,
                team0_.createdDate as createdD3_8_0_,
                team0_.lastModifiedBy as lastModi4_8_0_,
                team0_.lastModifiedDate as lastModi5_8_0_,
                team0_.name as name6_8_0_
            from
                Team team0_
            where
                team0_.id=?
        ```
        
    
    **즉시 로딩**
    
    한방 쿼리로 다 조회해온다.
    
    실행 결과를 보면 Team 객체는 프록시 객체가 아닌, 실제 객체이다.
    
    ```
    Hibernate:
        select
            member0_.id as id1_4_0_,
            member0_.createdBy as createdB2_4_0_,
            member0_.createdDate as createdD3_4_0_,
            member0_.lastModifiedBy as lastModi4_4_0_,
            member0_.lastModifiedDate as lastModi5_4_0_,
            member0_.age as age6_4_0_,
            member0_.description as descript7_4_0_,
            member0_.locker_id as locker_10_4_0_,
            member0_.roleType as roleType8_4_0_,
            member0_.team_id as team_id11_4_0_,
            member0_.name as name9_4_0_,
            locker1_.id as id1_3_1_,
            locker1_.name as name2_3_1_,
            team2_.id as id1_8_2_,
            team2_.createdBy as createdB2_8_2_,
            team2_.createdDate as createdD3_8_2_,
            team2_.lastModifiedBy as lastModi4_8_2_,
            team2_.lastModifiedDate as lastModi5_8_2_,
            team2_.name as name6_8_2_
        from
            Member member0_
        left outer join
            Locker locker1_
                on member0_.locker_id=locker1_.id
        left outer join
            Team team2_
                on member0_.team_id=team2_.id
        where
            member0_.id=?
    
    class hello.jpa.Team
    ```
    
    - 즉시 로딩은 N+1 문제를 일으킨다.
        - 쿼리 1개 날렸는데 그것때문에 추가 쿼리가 n개 나간다는 의미
    - 모든 member를 조회해오는데, member개수가 수천만명일 때, 결과가 매우 많아지기 때문에 실무에서 즉시 로딩을 사용할 땐 조심해야한다.
    - 만일 조인을 통해 조회해오는 경우, 모든 조인을 한방에 가져와서 슬로 쿼리가 될 수 있음.
- 트랜잭션 격리수준
    
    https://mangkyu.tistory.com/299
    
    수동 커밋일 경우에만 적용됨.
    
    ![Untitled (13)](https://github.com/uneap/tech-note/assets/25525648/d85ab3e2-23f3-41e0-ad0a-14aa3456edf5)

    
    **SERIALIZABLE**
    
    - 엄격한 격리 수준, 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없음. 따라서 데이터 부정합 문제가 발생하지 않음.
    - 그러나 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 떨어짐.
    - 순수한 읽기 작업인 SELECT 조차도 대상 레코드에 넥스트 키 락을 공유 락으로 걸음. 따라서 다른 트랜잭션에서는 해당 레코드를 추가,수정,삭제할 수 없음.
    
    **REPEATABLE READ**
    
    - 변경전의 레코드를 언두 공간에 백업해둠.
    - 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있다.
    - phantom read: select로 조회 시, 트랜잭션이 끝나기 전 다른 트랜잭션에 의해 추가된 레코드가 발견됨.
    - mysql에서 repeatable read에서 팬텀 리드가 발생하는 유일한 케이스는 B가 생성한 트랜잭션의 첫번째 select 당시 쓰기 잠금이 없는 select로 조회한 후, A가 생성한 트랜잭션에서 insert 작업 수행 한 뒤 커밋 후, B 생성 트랜잭션에서 두번째 select엔 쓰기 잠금이 있는 select for update를 쿼리하는 경우이다.
    - B가 생성한 트랜잭션의 첫번째 select 쿼리 후, A가 생성한 트랜잭션에서 insert 작업 수행 한 뒤 커밋 후, B 생성 트랜잭션에서 select 쿼리하는 경우
        - MVCC 덕분에, 현 트랜잭션 이후에 생긴 트랜잭션 버전을 통해 추가된 데이터는 무시하므로, 일반적인 조회에서는 phantom read가 발생하지 않는다.
    - B가 생성한 트랜잭션의 첫번째 select for update 쿼리 후 A가 생성한 트랜잭션에서 insert 작업 수행 한 뒤 커밋 후, B 생성 트랜잭션에서 select for update 쿼리하는 경우
        - 갭락이 존재하여 팬텀리드가 발생하지 않는다. insert 시도한다면, B의 트랜잭션이 종료될 때까지 기다리다가, 대기를 오래하면 락 타임아웃이 발생한다.
        - 갭락이 존재하지 않을 경우, **레코드 락** 쓰기 잠금을 건다. 잠금이 있는 읽기 작업은 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문에 팬텀 리드가 발생한다.
    
    **READ COMMITTED**
    
    - 커밋된 데이터만 조회 가능
    - 팬텀 리드, non-repeatable read(반복 읽기 불가능) 문제 발생
    - B 가 만든 트랜잭션의 첫번째 select 쿼리를 통해 100원 이었던 값을 A가 만든 트랜잭션에 update 로 100원을 200원으로 변경 후 커밋했다고 가정한다. 그 후 B가 만든 트랜잭션에서 두번째 select 쿼리를 수행하면 200원이 조회된다.
        - 이러한 데이터 부정합 문제를 반복 읽기 불가능 문제라 한다.
    - 해당 수준에서는 애초에 커밋된 데이터만 읽을 수 있기에, 트랜잭션에서 실행되는 select와 트랜잭션 밖에서 실행되는 select에 큰 차이가 없음.
    
    **READ UNCOMMITTED**
    
    - 커밋하지 않은 데이터도 접근할 수 있는 격리 수준
    - dirty read,팬텀 read, 반복 읽기 불가능 문제 발생
    - A가 만든 트랜잭션에서 insert문 실행 후, B가 만든 트랜잭션에서 select 쿼리 실행한다, 그 후 A에서 rollback한 뒤 B에서 select할 경우, 기존에는 있었던 데이터가 없어진다. 이를 dirty read라 한다.
    - 정합성에 문제가 많은 격리 수준이라 RDBMS 표준에서도 인정하지 않는다.
- 스토리지 엔진 level lock
    
    https://mangkyu.tistory.com/298
    
    **record lock**
    
    - 테이블 레코드를 잠그는 락
    - MySQL에서의 레코드 락은 테이블 레코드가 아닌 **인덱스**의 레코드를 잠금.
    - 락이 걸리는 대상은 클러스터 인덱스 및 논클러스터 인덱스 모두를 포함.
    - pk가 없는 테이블이라면 내부적으로 자동 생성된 pk를 이용해 설정
    - 적당한 인덱스가 없다면 모든 테이블 레코드에 락을 걸고, 테이블을 풀 스캔하면서 작업을 처리함.
        - 동시성이 상당히 떨어지므로, 인덱스 설계는 매우 중요
    
    **gap lock**
    
    - pantom 읽기 방지에 도움 됨.
    - 레코드 락이 테이블이 아닌 인덱스에 걸림.
    - 레코드가 아닌 레코드와 레코드 사이의 간격을 잠금.
    - 아직 존재하지 않지만 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금
    
    ```
    SELECT * FROM member WHERE last_name LIKE "J%" FOR UPDATE;         // 쓰기 잠금(베타락)
    ```
    
    ![Untitled (14)](https://github.com/uneap/tech-note/assets/25525648/b1b62687-986f-4bcc-8fdf-32af8b0d15a0)

    
    **next key lock**
    
    - 레코드락과 갭락을 합친 잠금
    - 바이너리 로그에 기록되는 쿼리가 리플리카 서버에서 실행 시, 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 주 목적임.
    - 그러나 해당 락으로 인해 데드락 발생하거나 다른 트랜잭션이 대기하는 일이 자주 발생하므로 바이너리 로그 포맷을 row 형태로 바꿔서 락을 줄이는 것이 좋다 함.
    
    **auto increment lock**
    
    - insert와 replace와 같이 새로운 레코드 저장 쿼리에서 사용
    - 중복되지 않고 순차적으로 증가하는 일련 번호를 제공하기 위한 테이블 수준 잠금
    - 잠금을 최소화 하기 위해 AUTO_INCREMENT 값은 한번 증가하면 절대 자동으로 줄지 않음
    - 만일 AUTO_INCREMENT로 설정된 id insert 쿼리가 포함된 트랜잭션이 실패하여 롤백되었다고 하더라도, 해당 값은 롤백되지 않고 그대로 남아서, 초기화 하려면 직접 쿼리를 통해 수정해야 한다.
    
    ```sql
    ALTER TABLE tablename AUTO_INCREMENT = 1;
    ```
    
- 바이너리 로그
    
    데이터 지속성을 위해, 복제 서버나 이중화를 위해 테이블 내 데이터를 소스 DB와 동일하게 저장하기 위해 남기는 로그로, 로깅 방식은 3가지이다.
    
    - statement
        - 데이터 변경에서 사용되는 모든 쿼리를 쿼리대로 저장하는 방식
    - row
        - 변경 작업으로 변경된 모든 row 정보를 기록하는 방식
        - 오랜 실행 시간동안 실행되나, 비교적 적은 수의 열만을 수정하는 query가 있다. 이러한 query들은 row 기반 로깅을 사용하여 복제하는 것이 효과적이다.
    - mixed
        - 기본은 statement 방식이고, 몇몇은 row로 기록하는 방식

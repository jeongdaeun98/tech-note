# Network

## OSI7계층
물데네전세표응
통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있다.
물 -> 응 decapsulation
응 -> 물 encapsulation
### 물리 - bit
- 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )

### 데이터링크 - frame
- 물리 계층으로 송수신 되는 정보를 관리하여 안전하게 전달되도록 도와줌.
-  프레임에 MAC 주소를 부여하고 통신함.
-  에러 검출, 재전송, 흐름제어를 진행함. ( 브릿지, 스위치 )

### 네트워크 - packet or datagram
- 라우터를 통해 이동할 경로를 선택 -> ip 주소 지정 -> 해당 경로에 따라 패킷을 전달
- 라우팅, 흐름제어, 오류제어, 세그먼테이션등을 수행

### 전송 - segment
- TCP와 UDP 프로토콜을 통해 통신 활성화
- 포트 열어두고, 프로그램들이 전송할 수 있도록 제공해준다.
tcp, udp

### 세션 - data
- 통신 시스템 host간의 연결을 유지 및 설정함
- tcp/ip 세션을 만들고 없애는 책임을 지니고 있음.
api, socket

### 표현 - data
- 데이터 표현에 대한 독립성을 제공하고, 암호화하는 역할을 담당
-  파일 인코딩, 명령어 포장, 압축, 암호화함.
jpeg, mpeg

### 응용 - data
- 최종 목적지로, 사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공함
http, ftp, dns

## TCP와 UDP가 나오게 된 이유?
1. IP의 역할은 Host to Host (장치 to 장치)만을 지원한다. 호스트간 이동은 IP로 해결되지만, 하나의 장비안에서 수많은 프로그램들이 통신을 할 경우에는 IP만으로는 한계가 있다.

2. 또한, IP에서 오류가 발생한다면 ICMP에서 알려준다. 하지만 ICMP는 알려주기만 할 뿐 대처를 못하기 때문에 IP보다 위에서 처리를 해줘야 한다.

3. 1번을 해결하기 위하여 포트 번호가 나오게 됐고, 2번을 해결하기 위해 상위 프로토콜인 TCP와 UDP가 나오게 되었다.
> ICMP : 인터넷 제어 메시지 프로토콜로 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송받는데 주로 쓰임

## TCP

### 3 way handshake
1. 클라이언트가 서버에게 syn 패킷 보냄
2. 서버는 패킷 수신 후, ack와 syn 패킷 보냄
3. 클라이언트는 ack와 syn 패킷 수신 후 ack를 서버로 보냄

### 4 way handshake - 연결 해제
1. 클라이언트는 서버에게 연결 종료한다는 fin 플래그 보냄
2. 서버는 fin플래그를 수신 후 확인했다는 ack를 클라이언트에게 보냄
2-1. 데이터를 모두 보낼때까지 잠깐 TIME_OUT이 됨.
4. 데이터를 모두 보냈다면 연결이 종료되었다고 클라이언트에게 fin 플래그를 보냄
5. 클라이언트는 fin 플래그 수신 후 ack를 보냄
6. 클라이언트의 ack를 받은 서버는 소켓 연결을 close함
7. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비하여 일정 시간 동안 **세션**을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 (TIME_WAIT) 
8. TIME_WAIT 시간이 끝나면 클라이언트도 연결을 close함.

### 네트워크 문제
1. 네트워크 혼잡
2. 패킷 순서
3. 패킷 손실
4. 수신자측의 과부하

### 신뢰있는 네트워크를 위한 해결방안
- 흐름제어
    - 수신자와 송신자측의 데이터 처리 속도 차이를 해결하기 위한 기법
    - 흐름 제어(flow control)은 수신자가 송신자로부터 받는 패킷을 조절하는 것
    - 기본 개념은 수신자가 송신자에게 자신의 상태를 feedback한다.
- 혼잡제어 
    - 송신자의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법

### 흐름제어

#### 문제점
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 재전송 등 발생
- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절하는 것

#### 해결방법
1. stop and wait
- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
2. sliding window
- 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송하는 방법
- 모든 호스트들은 윈도우를 가지고 있음.
- 송신 호스트 기준으로, 실제 데이터를 보내기 전에 '3 way handshaking'을 통해 수신 호스트의 윈도우 크기에 자신의 윈도우 크기를 맞춤.

### 혼잡제어

#### 문제점
- 만일 한 라우터에 데이터가 몰리게 될 경우, 처리량보다 수신량이 많아 모든 데이터를 처리하지 못한다. 따라서 송신 호스트는 재전송을 하고, 혼잡이 가중되어 데이터 손실이 발생된다.
- 따라서 이러한 혼잡을 피하기 위해 송신 측에서 데이터 전송 속도를 강제로 줄이는 것
- 흐름제어는 송신 호스트와 수신 호스트 사이의 전송 속도를 조절하는 반면, 혼잡제어는 호스트와 라우터를 포함한 더 넓은 관점에서 전송 문제를 다룬다.

#### 해결방법
- AIMD
    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
    - 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이며, 시간이 흐르면 평형상태로 수렴함.
- Slow Start(느린 시작)
    - AIMD는 윈도우 크기를 1씩 증가해가지만, ack 패킷 수신될 때마다 윈도우 크기를 1씩 늘려준다. 전송 속도는 AIMD에 반해 지수함수 꼴로 증가한다.
    - 대신 혼잡 현상이 발생하면 윈도우 크기를 1로 떨어뜨린다.
    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
    - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
- fast recovery(빠른 회복)
    - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
- fast retransmit(빠른 재전송)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/d10b0a00-eb27-4822-9da2-33b289602471/Untitled.png)
    
    - 패킷을 받는 쪽에서 3번 패킷이 도착하지 않고 4번 패킷이 도착한 경우, 2번에 대한 ack 패킷을 보낸다.
    - 그리고 지속적으로 다음 패킷을 순차적으로 보내게 되고, 수신자는 3번 패킷이 도달하지 않았음을 알리기 위해 2번에 대한 ack 패킷을 보내게 된다. 중복된 순번의 패킷을 3개 받으면 재전송을 한다.
    - 약간 홉잡한 상황이 일어난 것이므로 혼잡을 감지하고 윈도우 사이즈를 줄이게 된다.

## UDP?
- UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
- 주로 실시간 방송과 온라인 게임에서 사용된다.
- 송신한 데이터가 수신되었는지 점검하는 과정이 없다.
- 연결을 유지할 필요가 없다.
- reliability는 application layer에서 추가될 수 있다.

### DNS에서 UDP를 사용하는 이유
- Request의 양이 작음 -> UDP Request에 담길 수 있다.
- 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
- Request에 대한 손실은 Application Layer에서 제어가 가능하다.
- DNS : port 53번
- But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.

## HTTP & HTTPS

### HTTP
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- HTTP는 텍스트 교환으로 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안이슈 존재

### HTTPS
- 인터넷 상에서 정보를 암호화하는 ssl 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- 텍스트를 암호화한다.

> 1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
> 2. B는 암호문을 받고, 자신의 비밀키로 복호화함
> 3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
> 4. A는 자신의 대칭키로 암호문을 복호화함
> 5. 앞으로 이 대칭키로 암호화를 통신함
> 즉, 대칭키를 주고 받을 때만 공개키 암호화 방식 사용, 그 이후는 계속 대칭키 암호화 방식

### HTTPS 통신 흐름
1. a 서버는 a 서버의 공개키와 개인키를 만들고, 공개키를 CA기업에 돈을 지불하며 맡긴다.(CA기업은 인증된 기관이다.)
2. CA기업은 a서버의 공개키와, 공개키를 암호화하는 방법을 인증서로 만들어 그 인증서를 ca기업의 개인키로 암호화한다.
3. CA기업은 암호화된 인증서를 a 기업에게 전달한다.
4. 클라이언트가 a서버로 request를 날린다.
6. a서버는 클라이언트에게 인증서를 보낸다.
7. 클라이언트 입장에서는 인증서는 ca기업의 개인키로 암호화된 a서버의 인증서이다. 따라서 브라우저는 원래 알고 있던 ca 기업의 공개키로 인증서를 복호화하여 a서버의 공개키를 얻어낸다.
8. 클라이언트는 request를 공개키로 복호화하여 요청한다.

## 로드 밸런서
서버에 부하가 생기게 되면 데이터 손실, 서비스 중단 등 치명적일 수 있다.
따라서 서버를 여러개 두어서 데이터 손실과 서비스 중단 등을 방지할 수 있는데, 이때 로드 밸런서를 통해 클라이언트가 요청할 경우 여러 서버로 분산되도록 할 수 있다.

보통은 라운드 로빈 방식을 많이 사용한다.

- OSI 7계층
    
    물데네 전세표응
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/ce57009c-fcfb-4084-85e6-502b75c129cd/Untitled.png)
    
    계층 - 전송되는 단위
    
    **물리 - bit**
    
    - 이 계층에서는 데이터를 전기적인 신호인 0과 1, 즉 on과 off로 변환해서 주고 받는 기능만 할 뿐이고 데이터가 무엇인지 어떤 에러가 있는지 등 신경쓰지 않는다.
    - 통신 케이블, 리피터, 허브 를 통해 데이터를 전송한다.
    
    **데이터 링크 - frame**
    
    - 물리계층을 통해 전달되는 데이터의 오류와 흐름을 관리하여 안전한 통신의 흐름을 관리
    - 프레임에 물리적으로 할당받은 MAC 주소를 부여하고 에러 검출, 재전송, 흐름 제어 수행
    - 브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달
    
    **네트워크 - packet**
    
    - 데이터를 목적지까지 안전하고 빠르게 전달
    - 라우터를 통해 경로를 선택하고 IP주소를 정하고 경로에 따라 패킷을 전달
    - 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층
    - 라우터가 가장 대표적인 장비
    
    **전송 - segment**
    
    - port 번호, 전송 방식(TCP/UDP) 결정하며, TCP 헤더 붙음
    - 두 지점 간의 신뢰성 있는 데이터를 주고 받게 해주는 역할
    - 신호를 분산하고 다시 합치는 과정을 통해 에러와 경로를 제어
    
    **세션 -data**
    
    - 주 지점간의 프로세스 및 통신하는 호스트 간의 연결 유지
    - TCP/IP 세션 체결, 포트번호를 기반으로 통신 세션 구성
    - API, socket
    
    **표현 - data**
    
    - 전송하는 데이터의 표현 방식을 결정
    - 파일 인코딩, 명령어를 포장, 압축, 암호화
    - JPEG,MPEG, GIF, ASCII 등
    
    **응용 -data**
    
    - 최종 목적지로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행(chrome)
    - HTTP, SMTP, Telnet 과 같은 프로토콜이 있다.
    
- TCP/IP 4계층
    
    네인전응
    
    **네트워크 액세스 계층**
    
    1. OSI 7계층의 **물리계층(1)과 데이터 링크 계층(2)**에 해당
    2. 알맞은 하드웨어로 데이터가 전달되도록 MAC 주소를 설정하는 것 뿐만 아니라, 데이터 패킷을 전기신호로 변환하여 케이블을 통해 전달할 수 있게 준비
    
    **인터넷 계층**
    
    1. OSI 7계층의 네트워크 계층(3)에 해당
    2. IP를 사용하여 데이터의 원천지(origin)과 목적지(destination)에 관한 정보를 첨부
    3. 어드레싱(addressing), 패키징(packaging), 라우팅(routing) 기능을 제공
    4. IP는 패킷 전달 여부를 보장하지 않고 경로를 설정하여 빨리 보내는 역할
    5. 프로토콜 종류 – IP, ARP, RARP
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/17ef6400-f5bd-458a-bf16-6efa55b757fa/Untitled.png)
    
    **전송 계층**
    
    1. OSI 7계층의 전송 계층(4)에 해당
    2. **IP와 Port**를 이용하여 프로세스와 통신
    3. TCP/UDP를 담당하는 계층
    4. 애플리케이션 계층의 세션과 데이터그램(datagram) 통신서비스 제공
    5. 프로토콜 종류 – TCP, UDP
    
    **응용 계층**
    
    1. OSI 7계층의 **세션 계층(5), 표현 계층(6), 응용 계층(7)**에 해당한다.
    2. 프로그램(브라우저)가 직접 인터액트하는 레이어. 데이터를 처음으로 받는곳
    3.  다른 계층의 서비스에 접근할 수 있게 하는 애플리케이션을 제공
    4.  애플리케이션들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의
    5.  HTTP, SMTP등의 프로토콜을 가진다.
    6.  TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.
    7.  프로토콜 종류 – FTP, HTTP, SSH
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/34138571-27ac-4887-8302-c943934b166d/Untitled.png)
    
- TCP 4-Way Handshake
    - 세션을 종료하기 위해 수행되는 절차
    1. 클라이언트는 연결을 종료하겠다는 FIN 플래그를 전송한다.
    2. 서버는 ACK 메시지를 보내고 자신의 통신이 끝날 때까지 기다리는데 이 상태가 CLOSE_WAIT 상태다.
    3. 서버는 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.
    4. 클라이언트는 플래그를 받고 ACK 메세지를 보낸 후, 혹여라도 지연된 패킷을 모두 받을 때까지  TIME_WAIT 상태로 기다렸다가 통신을 종료한다.
    - 만일 TIME_WAIT 없이 서버에서 FIN 패킷을 전송한다면, 라우팅 지연이나 패킷 유실로 인한 재전송으로 인해 클라이언트에 지연 수신한 패킷은 유실될 것이다. 따라서 일정시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.
    - 참고로 CLOSE_WAIT는 가끔 어플리케이션의 교착 상태로 인해 close가 되지 않아 프로세스 강제 종료하지 않고는 FIN 플래그를 보내지 않게 되어 통신이 끊어지지 않는 경우가 발생한다.
- TCP 3-Way Handshake
    - TCP/IP 프로토콜을 이용하여 통신하는 응용프로그램이 데이터 전송 전, 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정
    - 서로 데이터를 전송할 준비가 되었다는 것을 보장하며 데이터 전달 시작 전, 한쪽은 다른 쪽이 준비되었다는 것을 알 수 있음.
    1. A 클라이언트 B 서버가 있다고 가정한다. A는 B 서버에 접속 요청 SYN 패킷을 전송한다. 이 때, A는 SYN을 보내고 ACK 응답을 기다리는 SYN_SENT 상태가 된다.
    2. B 서버는 Syn 요청을 받고 A 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고, A가 다시 ACK로 응답하기를 기다린다. 이 때 B 서버는 SYN_RECEIVED 상태가 된다.
    3. A서버는 B서버에게 ACK를 보내고 이후로부터 연결이 이루어지고 데이터가 오간다. B 서버는 ESTABLISHED 상태가 된다.
- HTTP 상태코드
    - **1xx (Information Response)**: 정보 메시지만을 나타낸다. 서버가 요청을 받았으며 서버에 연결된 클라이언트는 계속해서 작업을 하라는 뜻.
    - **2xx (Successful Response)**: 서버와의 요청이 성공함을 나타냄
    - **3xx (Redirection Message)** : 요청 완료를 위해 추가 작업 조치가 필요함을 의미함. 위 사진의 **301(Moved Permantly)**는 요청한 리소스의 URI가 변경 되었음을 뜻한다.
    - **4xx (Client Error Response)** : 클라이언트의 Request에 에러가 있음을 의미함.
    - **5xx (Server Error)** : 서버 측의 오류로 request를 수행할 수 없음.
- DNS (Domin Name System)
    
    DNS란 주소창에 입력한 도메인을 실제 네트워크 상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정을 말한다.
    
    DNS 서버는 계층형 구조로 이뤄져있다.
    
    [DNS 서버 질의 절차](https://www.notion.so/DNS-696ef2902cde40828a576140f6d11779?pvs=21) 
    
- 웹 브라우저에 URL을 입력했을 때의 수행 과정
    1. 브라우저 주소창에  **[www.google.com](http://www.google.com/) 를 입력한다.**
    2. HTTP Request를 보내기 위한 패킷을 만든다(HTTP, TCP, IP, Ethernet 프로토콜 사용한다고 가정)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/5529e479-c978-4092-aa9f-84964366a060/Untitled.png)
        
        1. 애플리케이션 계층에는 HTTP Request 헤더가 들어감
            
            ```jsx
             :authority: www.google.com
              :method: GET
              :path: /
              :scheme: https
              ...
              ...
            ```
            
        2. 전송 계층에는 TCP 헤더가 들어감
            
            출발지 port번호, 목적지 port 번호
            
        3. 인터넷 계층에는 IP 헤더가 들어감
            
            출발지 IP 주소, 목적지 IP 주소
            
            - DNS 서버 질의 절차
                1. IP 주소를 찾기 위해 브라우저는 캐시에서 DNS 기록을 확인한다.
                    1. DNS 쿼리는 우선 브라우저 캐시를 확인한다. 브라우저는 내가 이전에 방문한 웹 사이트의 DNS 기록을 일정 기간 동안 저장하고 있다.
                    2. OS 캐시를 확인한다. 브라우저가 내 컴퓨터 OS에 시스템 호출(ex. 윈도우에서 `gethostname` 호출)을 통해 DNS 기록을 가져온다. (OS도 DNS 레코드 캐시를 저장하고 있다.)
                    3. 브라우저는 라우터에서 DNS 기록을 저장한 캐시를 확인한다.
                    4. ISP 캐시를 확인한다. ISP(Internet Service Provider)는 **DNS 서버**를 가지고 있는데, 해당 서버에서 DNS 기록 캐시를 검색할 수 있다.
                2. 만약 캐시에 없다면, DNS 서버가 DNS 쿼리로 호스팅 서버의 IP 주소를 찾는다.
                    1. DNS 리커서 → 클라이언트의 DNS 서버, 쿼리를 수신하는 서버 → 네임 서버
                    2. 네임 서버는 도메인 이름의 도메인 아키텍처를 기반으로 DNS 검색을 수행
                    3. 재귀적 질의가 일어난다.
                    4. [www.google.com](http://www.google.com) 의 경우, 먼저 DNS 리커서가 루트 네임 서버에 연결한다.
                    5. 루트 네임 서버는 리커서를 .com  TLD 네임 서버로 리디렉션한다.
                    6. TLD 네임서버는 [google.com](http://google.com)  Authoritative 네임 서버로 리디렉션 한다.
                    7. Authoritative 네임 서버는 DNS 기록에서 [www.google.com](http://www.google.com) 과 일치하는 IP 주소를 찾아 DNS 리커서로 반환하고, 리커서는 이를 캐시에 저장하고, 브라우저로 보낸다.
        4. 네트워크 접근 계층에는 이더넷 헤더가 들어감
            
            출발지 MAC 주소, 목적지 MAC 주소
            물리적으로 연결된 라우터(공유기) 혹은 게이트 웨이의 MAC 주소
            
    3. 패킷을 전송하기 전, TCP 프로토콜의 3-way-handshaking을 통해 송신측과 수신측이 세션을 생성하는 작업을 수행한다.
    4. 이제 라우팅을 통해 패킷을 목적지 서버에게 전송한다.
        1. 패킷은 MAC주소와 IP 주소로 라우팅을 반복해 목적지 구글 서버까지 도착함.
        2. 구글 서버가 받은 패킷 내부 전송 계층의 목적지 포트 번호를 사용하고 있는 어플리케이션 계층에 데이터를 전송함.
        3. 어플리케이션 계층은 HTTP request를 받아 “/”에 매핑된 GET 요청을 처리함.
        4. 그 후, 적절한 HTML을 클라이언트에게 응답함.
        5. 따라서 브라우저는 해당 HTML을 띄우게 됨.
    5. 이제 HTTP 요청 및 응답 과정이 끝나 TCP 프로토콜의 4-way-handshaking을 통해 연결을 종료함.
        
        
- HTTP GET과 POST
    
    **GET**
    
    : 어떠한 정보를 조회하기 위해 사용되는 방식
    
    - 요청을 전송할 때 URL 주소 끝에 파라미터를 포함하여 요청한다. 이 부분을 쿼리 스트링이라 부른다.
    - 멱등성을 유지한다.
    - URL에 데이터가 노출되어 보안에 취약하다.
    - 캐싱할 수 있다.
    - 데이터 길이에 제한이 있다.
    - 브라우저에 기록이 남는다.
    
    **POST**
    
    : 리소스를 생성하기 위해 사용되는 방식
    
    - HTTP 메세지의 Body에 담아서 전송한다.
    - 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용 확인할 수 있으므로, 민감한 데이터는 반드시 암호화하여 전송해야 함.
    - 캐싱할 수 없음.
    - 브라우저 기록에 남아 있지 않음.
    - 데이터 길이에 제한 없음
    - 멱등성 유지하지 않음.
- time out
    
    ### connection timeout
    
    커넥션 요청에 대한 승인을 받는데 걸리는 시간에 대한 임계치
    
    ### socket time out
    
    packet 전송할 때 하나의 패킷이 아닌 여러개의 패킷으로 나누어 전송하는데, 패킷 사이에 전송 갭의 임계치
    
    ### read time out
    
    데이터 주고 받을 때 걸리는 최대 시간
    
    **데이터베이스 자원 부족:** 데이터베이스 서버가 처리할 수 있는 동시 요청의 양이 한계에 다다르면, 일부 요청은 처리 대기열에 들어가게 되고, 처리 시간이 증가할 수 있습니다.
    
    ### session timeout
    
    세션 연결 후 어떠한 요청을 받기까지 시간 임계치
    
    ### mysql - wait time out
    
    API를 이용한 client 프로그램(PHP, JDBC, ODBC...) 상에서 최대 연결시간을 말하며, 설정된 시간 동안 아무 요청이 없으면 연결은 취소되고 다시 요청이 들어오면 자동으로 연결이 맺어집니다.
    
    ---
    
    ## connection pool
    
    ### idle time out
    
    유휴 커넥션에 대해 timeout이 지나면 연결 해제
    
    ### keep alive time
    
    유휴 연결에 대해 keep alive time 시간이 지나면 주기적으로 커넥션이 유효한지 체크
    
    ### max life time
    
    connection의 유효기간, 연결된 connection에 대해서는 max life time이 지나면 연결 해제 시 삭제 됨
    
- TCP와 UDP
    
    **TCP**
    
    - 신뢰성을 보장하는 연결형 프로토콜
    - 흐름제어, 혼잡제어를 제공
    - 웹 HTTP 통신, 이메일, 파일 전송에서 사용
    
    **UDP**
    
    - UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
    - 주로 실시간 방송과 온라인 게임에서 사용된다.
    - 흐름제어, 혼잡제어를 제공하지 않는다.
    - 연결을 유지할 필요가 없다.
    - reliability는 application layer에서 추가될 수 있다.
    
    **DNS에서 UDP를 사용하는 이유**
    
    - Request의 양이 작음 -> UDP Request에 담길 수 있다.
    - 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
    - Request에 대한 손실은 Application Layer에서 제어가 가능하다.
    - DNS : port 53번
    - But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.
- 흐름제어
    - 뜻
        - 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 재전송 등 발생
        - 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절하는 것
    - 해결방법
        - stop and wait: 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/ec5f6096-cf79-4839-a938-64af6d1c04ba/Untitled.png)
        
        - slidng window: 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송하는 방법
        - 모든 호스트들은 윈도우를 가지고 있음.
        - 송신 호스트 기준으로, 실제 데이터를 보내기 전에 '3 way handshaking'을 통해 수신 호스트의 윈도우 크기에 자신의 윈도우 크기를 맞춤.
- 혼잡제어
    - 뜻
        - 만일 한 라우터에 데이터가 몰리게 될 경우, 처리량보다 수신량이 많아 모든 데이터를 처리하지 못한다. 따라서 송신 호스트는 재전송을 하고, 혼잡이 가중되어 데이터 손실이 발생된다.
        - 따라서 이러한 혼잡을 피하기 위해 송신 측에서 데이터 전송 속도를 강제로 줄이는 것
        - 흐름제어는 송신 호스트와 수신 호스트 사이의 전송 속도를 조절하는 반면, 혼잡제어는 호스트와 라우터를 포함한 더 넓은 관점에서 전송 문제를 다룬다.
    - 해결 방법
        - AIMD
            - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
            - 패킷 전송에 실패하거나 일정 시간을 넘으면 윈도우 사이즈**를 절반으로 줄인다**.
            - 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이며, 시간이 흐르면 평형상태로 수렴함.
        - Slow Start(느린 시작)
            - AIMD는 윈도우 크기를 1씩 증가해가지만, ack 패킷 수신될 때마다 윈도우 크기를 2배씩 증가시킨다. 전송 속도는 AIMD에 반해 지수함수 꼴로 증가한다.
            - 대신 혼잡 현상이 발생하면 윈도우 크기를 1로 떨어뜨린다.
            - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
            - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
        - fast recovery(빠른 회복)
            - 느린 시작과의 차이는 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
        - fast retransmit(빠른 재전송)
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33ee8fb8-7750-4080-9dcd-a97559596c7c/d10b0a00-eb27-4822-9da2-33b289602471/Untitled.png)
            
            - 패킷을 받는 쪽에서 3번 패킷이 도착하지 않고 4번 패킷이 도착한 경우, 2번에 대한 ack 패킷을 보낸다.
            - 그리고 지속적으로 다음 패킷을 순차적으로 보내게 되고, 수신자는 3번 패킷이 도달하지 않았음을 알리기 위해 2번에 대한 ack 패킷을 보내게 된다. 중복된 순번의 패킷을 3개 받으면 재전송을 한다.
            - 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 윈도우 사이즈를 줄이게 된다.
- CORS
    - 교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는 추가 **HTTP 헤더**를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제
    - SOP(Same Original Policy)로 인해 다른 출처의 선택한 자원에 권한이 없을 경우 접근할 수 없다. 따라서 CORS 를 통해 해결해야 한다.
    - 스프링에서는 CorsConfigurationSource로 CORS 허용 설정을 하며, addAllowedOrigin(), addAllowedHeader(), addAllowedMethod() 를 통해 허용할 URL, Header, Http Method를 설정할 수 있다.
    - 출처란?
        - Protocol과 Host,  :80, :443과 같은 포트 번호까지 모두 합친것
### CORS
    - 교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제
    - SOP(Same Original Policy)로 인해 다른 출처의 선택한 자원에 권한이 없을 경우 접근할 수 없다. 따라서 CORS 를 통해 해결해야 한다.
    - 스프링에서는 CorsConfigurationSource로 CORS 허용 설정을 하며, addAllowedOrigin(), addAllowedHeader(), addAllowedMethod() 를 통해 허용할 URL, Header, Http Method를 설정할 수 있다.
    - 출처란?
        - Protocol과 Host,  :80, :443과 같은 포트 번호까지 모두 합친것

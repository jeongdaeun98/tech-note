# Network

## OSI7계층
물데네전세표응
통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있다.
물 -> 응 decapsulation
응 -> 물 encapsulation
### 물리 - bit
- 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )

### 데이터링크 - frame
- 물리 계층으로 송수신 되는 정보를 관리하여 안전하게 전달되도록 도와줌.
-  프레임에 MAC 주소를 부여하고 통신함.
-  에러 검출, 재전송, 흐름제어를 진행함. ( 브릿지, 스위치 )

### 네트워크 - packet or datagram
- 라우터를 통해 이동할 경로를 선택 -> ip 주소 지정 -> 해당 경로에 따라 패킷을 전달
- 라우팅, 흐름제어, 오류제어, 세그먼테이션등을 수행

### 전송 - segment
- TCP와 UDP 프로토콜을 통해 통신 활성화
- 포트 열어두고, 프로그램들이 전송할 수 있도록 제공해준다.
tcp, udp

### 세션 - data
- 통신 시스템 host간의 연결을 유지 및 설정함
- tcp/ip 세션을 만들고 없애는 책임을 지니고 있음.
api, socket

### 표현 - data
- 데이터 표현에 대한 독립성을 제공하고, 암호화하는 역할을 담당
-  파일 인코딩, 명령어 포장, 압축, 암호화함.
jpeg, mpeg

### 응용 - data
- 최종 목적지로, 사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공함
http, ftp, dns

## TCP와 UDP가 나오게 된 이유?
1. IP의 역할은 Host to Host (장치 to 장치)만을 지원한다. 호스트간 이동은 IP로 해결되지만, 하나의 장비안에서 수많은 프로그램들이 통신을 할 경우에는 IP만으로는 한계가 있다.

2. 또한, IP에서 오류가 발생한다면 ICMP에서 알려준다. 하지만 ICMP는 알려주기만 할 뿐 대처를 못하기 때문에 IP보다 위에서 처리를 해줘야 한다.

3. 1번을 해결하기 위하여 포트 번호가 나오게 됐고, 2번을 해결하기 위해 상위 프로토콜인 TCP와 UDP가 나오게 되었다.
> ICMP : 인터넷 제어 메시지 프로토콜로 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송받는데 주로 쓰임

## TCP

### 3 way handshake
1. 클라이언트가 서버에게 syn 패킷 보냄
2. 서버는 패킷 수신 후, ack와 syn 패킷 보냄
3. 클라이언트는 ack와 syn 패킷 수신 후 ack를 서버로 보냄

### 4 way handshake - 연결 해제
1. 클라이언트는 서버에게 연결 종료한다는 fin 플래그 보냄
2. 서버는 fin플래그를 수신 후 확인했다는 ack를 클라이언트에게 보냄
2-1. 데이터를 모두 보낼때까지 잠깐 TIME_OUT이 됨.
4. 데이터를 모두 보냈다면 연결이 종료되었다고 클라이언트에게 fin 플래그를 보냄
5. 클라이언트는 fin 플래그 수신 후 ack를 보냄
6. 클라이언트의 ack를 받은 서버는 소켓 연결을 close함
7. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비하여 일정 시간 동안 **세션**을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 (TIME_WAIT) 
8. TIME_WAIT 시간이 끝나면 클라이언트도 연결을 close함.

### 네트워크 문제
1. 네트워크 혼잡
2. 패킷 순서
3. 패킷 손실
4. 수신자측의 과부하

### 신뢰있는 네트워크를 위한 해결방안
- 흐름제어
    - 수신자와 송신자측의 데이터 처리 속도 차이를 해결하기 위한 기법
    - 흐름 제어(flow control)은 수신자가 송신자로부터 받는 패킷을 조절하는 것
    - 기본 개념은 수신자가 송신자에게 자신의 상태를 feedback한다.
- 혼잡제어 
    - 송신자의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법

### 흐름제어

#### 문제점
- 송신측의 속도가 빠를경우, 수신측의 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실될 수 있다.
    - 만약 손실된다면 불필요한 응답과 데이터 전송이 송/수신 측 간에 빈번하게 발생한다.

#### 해결방법
1. stop and wait
- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
2. sliding window
- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여,
데이터 흐름을 동적으로 조절

### 혼잡제어

#### 문제점
- 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없음
- 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생

#### 해결방법
1. AIMD
- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 **패킷을 보내는 속도**를 절반으로 줄인다
- 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식
2. slow start
- Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다.
- 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
3. fase retransmit
- 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
- 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 
- 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
4. fast recovery
- 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
- 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다

## UDP?
- UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
- 주로 실시간 방송과 온라인 게임에서 사용된다.
- 송신한 데이터가 수신되었는지 점검하는 과정이 없다.
- 연결을 유지할 필요가 없다.
- reliability는 application layer에서 추가될 수 있다.

### DNS에서 UDP를 사용하는 이유
- Request의 양이 작음 -> UDP Request에 담길 수 있다.
- 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
- Request에 대한 손실은 Application Layer에서 제어가 가능하다.
- DNS : port 53번
- But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.

## HTTP & HTTPS

### HTTP
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- HTTP는 텍스트 교환으로 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안이슈 존재

### HTTPS
- 인터넷 상에서 정보를 암호화하는 ssl 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- 텍스트를 암호화한다.

> 1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
> 2. B는 암호문을 받고, 자신의 비밀키로 복호화함
> 3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
> 4. A는 자신의 대칭키로 암호문을 복호화함
> 5. 앞으로 이 대칭키로 암호화를 통신함
> 즉, 대칭키를 주고 받을 때만 공개키 암호화 방식 사용, 그 이후는 계속 대칭키 암호화 방식

### HTTPS 통신 흐름
1. a 서버는 a 서버의 공개키와 개인키를 만들고, 공개키를 CA기업에 돈을 지불하며 맡긴다.(CA기업은 인증된 기관이다.)
2. CA기업은 a서버의 공개키와, 공개키를 암호화하는 방법을 인증서로 만들어 그 인증서를 ca기업의 개인키로 암호화한다.
3. CA기업은 암호화된 인증서를 a 기업에게 전달한다.
4. 클라이언트가 a서버로 request를 날린다.
6. a서버는 클라이언트에게 인증서를 보낸다.
7. 클라이언트 입장에서는 인증서는 ca기업의 개인키로 암호화된 a서버의 인증서이다. 따라서 브라우저는 원래 알고 있던 ca 기업의 공개키로 인증서를 복호화하여 a서버의 공개키를 얻어낸다.
8. 클라이언트는 request를 공개키로 복호화하여 요청한다.

## 로드 밸런서
서버에 부하가 생기게 되면 데이터 손실, 서비스 중단 등 치명적일 수 있다.
따라서 서버를 여러개 두어서 데이터 손실과 서비스 중단 등을 방지할 수 있는데, 이때 로드 밸런서를 통해 클라이언트가 요청할 경우 여러 서버로 분산되도록 할 수 있다.

보통은 라운드 로빈 방식을 많이 사용한다.


1. 사용자가 브라우저에 도메인 네임(www.naver.com)을 입력한다.
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3. 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
4. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.
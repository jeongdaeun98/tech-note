# 브로커 내부 동작

### 카프카 브로커의 역할?

- 카프카 브로커는 프로듀서나 컨슈머 클라이언트의 요청을 처리하고 응답
- 모든 요청은 항상 수신된 순서로 처리된다.
- 따라서 저장되는 메시지의 순서가 보장된다. → 그러나 보통 처리량을 높이기 위해 파티션을 여러개로 설정하는데, 이 때 라운드 로빈 방식으로 메세지가 보내지긴 하지만, 컨슈머가 메세지를 받을 때, 메세지 순서는 보장불가.

### 카프카 브로커 내부 구성 요소

- acceptor 스레드
    - 네트워크 연결 생성
- 네트워크 스레드
    - 클라이언트 연결로부터 요청 큐로 요청을 전달, 응답큐에 응답이 들어올 경우, 클라이언트에게 전송
- 입출력 스레드
    - 요청큐에 요청이 들어올 경우, 해당 요청에 따라 처리
- 요청큐
- 응답큐

### 카프카 브로커 내부 요청 흐름?

![https://i.imgur.com/xnRFPMa.jpg](https://i.imgur.com/xnRFPMa.jpg)

1. 브로커는 자신이 리스닝 하는 각 포트에 대해서 acceptor 스레드를 실행
2. 네트워크 스레드가 그 다음을 처리하도록 넘겨줌.
    1. 네트워크 스레드는 클라이언트 연결로부터 요청을 받고 그것을 요청큐에 넣으며 응답큐로부터 응답을 가져와서 클라이언트에게 전송하는 일을 수행.
3. 일단 요청이 요청 큐에 위치하면 입출력 스레드가 각 요청을 가져와서 처리하는 책임을 갖는다.

### 카프카 브로커가 쓰기 요청을 받았을 때 흐름?

1. 특정 파티션의 리더 리플리카를 포함하는 브로커가 해당 파티션의 쓰기 요청을 받았을 경우 여러가지를 검사한다.
2. 데이터를 전송한 사용자가 해당 토픽의 쓰기 권한을 갖고 있는지, 해당 요청에 지정된 acks 값이 적합한지, 만일 acks가 all로 되어있다면, min.insync.replicas로 설정된 리플리카 개수에 만큼 충분한 동기화 리플리카들이 있는지를 검사한다.
3. 그 다음 브로커는 로컬 디스크에 새로 받은 메시지를 쓴다.
4. acks가 0과 1일 경우 즉시 응답을 전송한다. 그렇지 않고 all이면 팔로어 리플리카들이 해당 메시지를 복제했는지 리더가 확인할 때까지 퍼거토리라 하는 버퍼에 해당 요청을 저장한다.

### 카프카 브로커가 읽기 요청을 받았을 때 흐름?

![https://i.imgur.com/6spvHQG.jpg](https://i.imgur.com/6spvHQG.jpg)

1. 클라이언트가 요청에 지정한 최대, 최소 크기까지의 메시지들을 브로커가 해당 파티션에서 읽은 후 클라이언트에게 전송한다.
    1. 메시지 크기를 제한하지 않으면 클라이언트의 메모리 부족을 초래할 만큼 큰 응답을 브로커가 전송할 수 있다. 
    2. 클라이언트는 반환 데이터의 최소 크기도 설정할 수 있다. 이는 CPU와 네트워크 사용을 줄일 수 있는 방법이다. 
    3. 따라서 브로커는 최소 크기만큼 데이터가 채워지기를 기다렸다가 전송한다. 
    4. 그렇지만 주어진 시간이 넘어가게 되면 채워지지 않더라도 바로 전송한다.

2. 카프카는 제로 카피 기법을 사용하여 클라이언트에게 일관성을 위해 모든 리플리카에 복제된 메세지만 전송한다.
3. 제로 카피기법은 메시지를 중간 버퍼 메모리에 쓰지 않고 곧바로 네트워크 채널로 전송한다. 
→ 이렇게 하면 메모리로부터 데이터를 복사하고 버퍼를 관리하는 부담을 제거하므로 성능이 훨씬 향상
4. 만일 동기화 되지 않은 데이터도 읽었을 경우, 동기화되기 전 리더가 죽었을 때 새로운 리더가 선출되는데 다른 컨슈머들은 읽지 않았던 데이터를 읽게 되어 일관성이 결여될 수 있다.


![https://i.imgur.com/HxHXZSu.jpg](https://i.imgur.com/HxHXZSu.jpg)

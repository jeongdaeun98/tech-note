# 브로커 내부 동작

### 어떻게 카프카 클라이언트가 토픽에 대한 정보를 알 수 있는 것인지?

![https://i.imgur.com/l9Jen7M.jpg](https://i.imgur.com/l9Jen7M.jpg)

브로커에 메타데이터 요청을 통해 정보를 알 수 있다. 그 정보에는 토픽에 존재하는 파티션들, 각 파티션의 리플리카, 어떤 리플리카가 리더인지에 대한 정보를 포함한다.클라이언트는 대부분 그 정보를 캐시에 보존 후 토픽에 해당하는 파티션 리더에게 쓰기 혹은 읽기 요청을 전송한다. 또한 가끔 그런 정보를 새로 교체해야한다. 교체 주기는 config로 제어한다.

> 메타데이터 요청은 모든 브로커에 전송해도 상관없다. 모든 브로커가 그 정보를 포함하는 메타데이터 캐시를 갖고 있기 때문이다.
> 

### 메타 데이터 캐시를 교체하지 않을 경우

파티션 리더가 아니라는 에러를 받게 될텐데 그런 에러를 받게 되면 또다시 그 파티션에게 요청을 하지 않고 메타데이터 요청을 한다.메타데이터 캐시가 교체되지 않아 오래된 정보를 사용하여 엉뚱한 브로커에게 요청을 전송한 것이기 때문이다.

### 카프카 브로커의 역할?

카프카 브로커는 프로듀서나 컨슈머 클라이언트의 요청을 처리하고 응답한다. 모든 요청은 항상 수신된 순서로 처리된다. 따라서 저장되는 메시지의 순서가 보장된다.

### 카프카 브로커 내부 요청 흐름?

![https://i.imgur.com/xnRFPMa.jpg](https://i.imgur.com/xnRFPMa.jpg)

브로커는 자신이 리스닝 하는 각 포트에 대해서 acceptor 스레드를 실행하며 이 스레드는 연결을 생성하고 네트워크 스레드가 그 다음을 처리하도록 넘겨준다.네트워크 스레드는 클라이언트 연결로부터 요청을 받고 그것을 요청큐에 넣으며 응답큐로부터 응답을 가져와서 클라이언트에게 전송하는 일을 수행한다.일단 요청이 요청 큐에 위치하면 입출력 스레드가 각 요청을 가져와서 처리하는 책임을 갖는다.

### 카프카 브로커가 쓰기 요청을 받았을 때 흐름?

> acks 매개변수에 따라 메시지를 수신해야하는 브로커 수를 설정하며 그 값의 브로커가 모두 메시지를 수신해야 쓰기 성공으로 간주한다.
> 
1. 특정 파티션의 리더 리플리카를 포함하는 브로커가 해당 파티션의 쓰기 요청을 받았을 경우 여러가지를 검사한다.
2. 데이터를 전송한 사용자가 해당 토픽의 쓰기 권한을 갖고 있는지, 해당 요청에 지정된 acks 값이 적합한지, 만일 acks가 all로 되어있다면 메시지를 안전하게 쓰는데 충분한 동기화 리플리카들이 있는지를 검사한다.
3. 그 다음 브로커는 로컬 디스크에 새로 받은 메시지를 쓴다.
4. acks가 0과 1일 경우 즉시 응답을 전송한다. 그렇지 않고 all이면 팔로어 리플리카들이 해당 메시지를 복제했는지 리더가 확인할 때까지 퍼거토리라 하는 버퍼에 해당 요청을 저장한다.

### 카프카 브로커가 읽기 요청을 받았을 때 흐름?

![https://i.imgur.com/6spvHQG.jpg](https://i.imgur.com/6spvHQG.jpg)

1. 클라이언트가 요청에 지정한 최대, 최소 크기까지의 메시지들을 브로커가 해당 파티션에서 읽은 후 클라이언트에게 전송한다.

> 메시지 크기를 제한하지 않으면 클라이언트의 메모리 부족을 초래할 만큼 큰 응답을 브로커가 전송할 수 있다.클라이언트는 반환 데이터의 최소 크기도 설정할 수 있다. 이는 CPU와 네트워크 사용을 줄일 수 있는 방법이다. 따라서 브로커는 최소 크기만큼 데이터가 채워지기를 기다렸다가 전송한다. 그렇지만 주어진 시간이 넘어가게 되면 채워지지 않더라도 바로 전송한다.
> 

![https://i.imgur.com/HxHXZSu.jpg](https://i.imgur.com/HxHXZSu.jpg)

2. 카프카는 제로 카피 기법을 사용하여 클라이언트에게 일관성을 위해 모든 ISR에 쓴 메시지들만 전송한다.

> 제로 카피기법은 메시지를 중간 버퍼 메모리에 쓰지 않고 곧바로 네트워크 채널로 전송한다. 이렇게 하면 메모리로부터 데이터를 복사하고 버퍼를 관리하는 부담을 제거하므로 성능이 훨씬 향상된다.만일 동기화 되지 않은 데이터도 읽었을 경우, 동기화되기 전 리더가 죽었을 때 새로운 리더가 선출되는데 다른 컨슈머들은 읽지 않았던 데이터를 읽게 되어 일관성이 결여될 수 있다.
>
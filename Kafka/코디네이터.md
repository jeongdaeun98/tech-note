## 컨슈머 코디네이터

- 컨슈머 리밸런스, 오프셋 초기화, 오프셋 커밋을 담당
- ConsumerCoordinator 내부엔 heartbeat 스레드가 존재
    - poll 메서드 호출 시, ConsumerCoordinator는 heartbeat 스레드를 생성한다.
- 해당 스레드는 주기적으로 heartbeat을 그룹 코디네이터에게 전송
    - 파티션 소유권을 유지하기 위함.

## 그룹 코디네이터

- 그룹이 구독한 **토픽**과 **파티션**을 관리
- 컨슈머 **그룹의 상태**를 체크, 컨슈머와 매칭되도록 파티션 분배
- 브로커 중 하나

## HeartBeat Thread

![Untitled (10)](https://github.com/uneap/tech-note/assets/25525648/76ac2c3c-f0f9-48b2-9c35-1577114a3164)


### 배경

- heartBeat 시간과 polling 간격 시간이 구분되지 않아, 싱글 스레드로 consumer를 사용할 때 polling 간격이 session timeout을 초과하면 컨슈머 그룹에서 제외되는 문제가 있었음.
    - 데이터 처리 시간이 항상 session timeout보다 긴 경우, 사용자가 문제를 인지하고 수정하기 전까지는 프로세스가 진행되지 않는 문제가 있었음.
- heartBeat thread가 생기면서 polling과 heatbeat 시간 구분이 가능해짐.
    - heartbeat을 보낸 뒤 session time out이 초과할 때까지 heart beat을 보내지 않으면 컨슈머 그룹에서 제외

### 특징

- heartbeat.interval.ms 간격으로 heartbeat 전송

---

# 리밸런싱

- 파티션의 소유권이 다른 컨슈머에게 이전되는 작업이며, 유휴 컨슈머가 발생하지 않도록 처리량을 높이기 위해 파티션 분배 작업
- 리밸런스가 발생한 컨슈머 그룹은 리밸런스 작업이 끝날 때까지 브로커로부터 데이터를 가져오지 못함.
    - 리밸런싱은 컨슈머가 데이터 처리하는 도중 언제든지 발생할 수 있으므로 데이터 처리 중 발생한 리밸런싱에 대응하는 코드를 작성해야 함.
- 리밸런싱은 컨슈머 쪽의 운영 상태에 일시적인 영향을 줄 수 있으므로 컨슈머, 파티션의 추가가 필요하다면 충분한 고려 후에 추가하는 것을 추천

## 추가되는 상황

1. 파티션 추가
2. 컨슈머 그룹에 새로운 컨슈머가 추가
3. 컨슈머 그룹에 속해 있던 컨슈머가 제외됨
    1. [session.timeout.ms](http://session.timeout.ms) 에 설정된 시간 내에 heatbeat를 그룹 코디네이터에게 보내지 않으면 코디네이터는 해당 컨슈머가 죽은 것으로 판단 
    2. [max.poll.interval.ms](http://max.poll.interval.ms) 에 설정된 시간 이내에 폴링을 보내지 않을 경우, 컨슈머에 이상이 있다고 판단하여 그룹에서 컨슈머를 제외함.

## ⭐카프카 컨슈머에서의 리밸런싱 과정⭐

1. 컨슈머가 그룹 참여를 요청하기 위해서는 먼저 그룹 코디네이터를 찾아야 한다.
2. 그룹 코디네이터는 컨슈머 그룹 내의 모든 컨슈머들의 파티션 소유권을 빼앗고, 컨슈머들의 그룹 참여 요청(join group)을 기다린다.
3. 요청을 보내기 전, heartbeat스레드가 그룹 참여를 방해하지 못하도록 해당 스레드를 일시 정지 시킴
4. 만일 join group을 [max.poll.interval.ms](http://max.poll.interval.ms) 에 설정된 시간 이내에 보내지 않은 컨슈머는 컨슈머 그룹에서 제외됨.
5. 그룹 코디네이터는 가장 처음으로 그룹에 참여한 클라이언트를 리더로 선출함. 
6. 리더로 선정된 컨슈머는 partition.assignment.strategy 로 설정한 파티션 할당 전략에 맞춰, 컨슈머에게 파티션을 할당.
    - Assignor
        
        컨슈머와 파티션 할당 정책은 컨슈머의 어싸이너에 의해 결정됨.
        
        사실 어떤 assignor를 설정하던 파티션과 컨슈머는 1:1 매핑이 되므로 크게 상관 없음.
        
        - RangeAssignor: 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬하여 할당.(기본 값)
            
            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90a3faa8-d704-42a8-8d6e-f3cca49e84d2/Untitled.png)
            
        - RoundRobinAssignor: 모든 파티션을 컨슈머에서 번갈아가면서 할당.
        - StickyAssignor: 최대한 파티션을 균등하게 배분하면서 할당.
7. 그룹에 참여한 모든 컨슈머는 그룹 코디네이터에게 syncGroup 요청을 보내고, 리더는 파티션 할당 결과를 해당 요청에 포함시킴.
8. 그룹 코디네이터는 응답으로 컨슈머에 할당된 토픽, 파티션 정보를 보냄.
9. 응답을 받은 컨슈머는 할당된 토픽, 파티션 정보를 subscription state에 assign 메서드를 활용하여 업데이트함.

---

## 스태틱 멤버십

- 컨슈머 그룹 내 컨슈머가 재시작 등으로 그룹에서 나갔다가 다시 합류하더라도 리밸런싱이 일어나지 않게 하는 기능
    - 컨슈머 서버의 하드웨어 점검이나 소프트웨어 업데이트와 같은 작업으로 인해 재시작을 해야할 때  불필요한 리밸런싱 막기 위해 등장
- [group.instance.id](http://group.instance.id) 값을 컨슈머를 식별하기 위한 값으로 입력하고 session.timeout.ms를 큰값으로 입력해야 한다.
    - 지정된 시간동안 그룹 코디네이터가 하트비트를 받지 못할 경우 강제로 리밸런싱이 일어나기 때문임.
- 스태틱 맴버십 또한 [session.timeout.ms](http://session.timeout.ms/) 시간을 넘어갈 경우 리밸런싱이 일어나기 때문에 진행하는 작업 시간을 고려하여 설정

# 오프셋 초기화

## 오프셋 초기화를 하는 이유

- 브로커에서 데이터를 읽기 위해서는 파티션의 초기 오프셋 값이 필요.
- 초기 오프셋 값이 없을 경우, 컨슈머는 컨슈머 코디네이터를 통해 커밋된 오프셋 값을 확인함.

## 종류

1. 커밋된 오프셋이 있는 경우
2. 없는 경우

### 커밋된 오프셋 있는 경우

1. 컨슈머 코디네이터는 offsetFetch API 를 통해 그룹 코디네이터에게 커밋된 오프셋을 요청 
2. 그룹 코디네이터는 응답으로 커밋된 오프셋을 알려줌
3. 컨슈머 코디네이터는 응답으로 받은 오프셋을 subscriptionState에 업데이트함.
    1. fetcher가 subscriptionState의 seek를 호출해서 응답으로 받은 오프셋을 파티션의 오프셋 초기값으로 설정함.

### 없는 경우

1. **auto.offset.reset** 설정에 따라 오프셋을 초기화 함. 
2. fetcher는 파티션의 가장 처음 오프셋과, 마지막 오프셋을 알기 위해, 파티션 리더 브로커로 timestamp에 해당하는 오프셋을 조회하는 ListOffsets API를 활용함.
3. 응답으로 받은 오프셋 값은 SubscriptionState의 seek 메서드를 통해 파티션의 초기 오프셋으로 설정됨.

# 오프셋 커밋

- 컨슈머는 브로커로부터 데이터를 어디까지 가져갔는지 그룹 코디네이터에 커밋을 통해 기록

### `enable.auto.commit` = true : default

- 만약  KafkaConsumer가 auto.commit.interval.ms(default: 5초)마다 오프셋을 자동으로 커밋한다.
- 컨슈머 동작 이슈가 발생하여 __consumer _offsets 토픽에 어느 레코드까지 읽어갔는지 오프셋 커밋이 기록되지 못했다면 데이터 처리의 중복이 발생할 수 있음.
- 즉, 자동 커밋 방식은 편리하지만 리밸런스나 비정상적인 클라이언트 종료 등으로 데이터 누락이 발생할 수 있다.
- 따라서 데이터 처리의 중복이 발생하지 않게 하기 위해, 컨슈머 애플리케이션이 오프셋 커밋을 정상적으로 처리했는지 검증해야 한다.

### `enable.auto.commit` = false

- 오프셋 수동 커밋으로 설정할 경우, commitsync는 동기라서 커밋이 완료될때까지 대기하므로 컨슈머가 중지된다.
- 중지되지 않기 위해선 commitasync로 커밋을 비동기로 수행한다.
    - 하지만 데이터 순서는 보장되지 않으며 메시지 손실에 주의해야 한다.
        
        → 리밸런스나 비정상적인 클라이언트 종료로 데이터 누락 발생할 수 있다.

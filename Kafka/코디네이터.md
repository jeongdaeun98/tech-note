## 그룹 코디네이터

- 그룹이 구독한 **토픽**과 **파티션**을 관리
- 컨슈머 **그룹의 상태**를 체크, 컨슈머와 매칭되도록 분배

## 컨슈머 코디네이터

- 컨슈머 리밸런스, 오프셋 초기화, 오프셋 커밋을 담당
- ConsumerCoordinator 내부엔 heartbeat 스레드가 존재
- 해당 스레드는 주기적으로 heartbeat을 그룹 코디네이터에게 전송
    - heatbeat는 파티션 소유권을 유지하기 위함.
    - 컨슈머가 폴링할 때 혹은 읽은 메시지를 커밋할 때 하트비트는 자동 전송.
    - 폴링은 메시지를 읽는 것을 말하며 주로 무한루프에서 연속적으로 수행

## HeartBeat Thread

### 배경

- heatBeat 시간과 polling 간격 시간이 구분되지 않아, 싱글 스레드로 consumer를 사용할 때 polling 간격이 session timeout을 초과하면 컨슈머 그룹에서 제외되는 문제가 있었음.
- 데이터 처리 시간이 항상 session timeout보다 긴 경우, 사용자가 문제를 인지하고 수정하기 전까지는 프로세스가 진행되지 않는 문제가 있었음.
- heatbeat thread가 생기면서 polling과 heatbeat 구분이 가능해짐.

# 리밸런싱

카프카의 독특한 fail over 방식

- 파티션의 소유권이 다른 컨슈머에게 이전됨
- 리밸런스가 발생한 컨슈머 그룹은 리밸런스 작업이 끝날 때까지 브로커로부터 데이터를 가져오지 못함.
    - 리밸런싱은 컨슈머가 데이터 처리하는 도중 언제든지 발생할 수 있으므로 데이터 처리 중 발생한 리밸런싱에 대응하는 코드를 작성해야 함.
- 가용성과 확장성을 높여주기 위해 필요로 되는 작업

## 추가되는 상황

1. 토픽에 변경 사항이 생기는 상황
2. 컨슈머 그룹에 새로운 컨슈머가 추가되는 상황
3. 컨슈머 그룹에 속해 있던 컨슈머가 제외되는 상황
    1. [session.timeout.ms](http://session.timeout.ms) 에 설정된 시간 내에 heatbeat를 그룹 코디네이터에게 보내지 않으면 코디네이터는 해당 컨슈머가 죽은 것으로 판단 

## ⭐카프카 컨슈머에서의 리밸런싱 과정⭐

### 1. 그룹 코디네이터 찾기

- 컨슈머가 그룹 참여를 요청하기 위해서는 먼저 그룹 코디네이터를 찾아야 한다.

### 2. Join

- 컨슈머 코디네이터는 그룹 코디네이터에게 그룹 참여를 요청(join group)
    - 요청을 보내기 전, heartbeat스레드가 그룹 참여를 방해하지 못하도록 해당 스레드를 일시 정지 시킴
    - 만일 join group을 [max.poll.interval.ms](http://max.poll.interval.ms) 에 설정된 시간 이내에 보내지 않은 컨슈머는 컨슈머 그룹에서 제외됨.
- 그룹 코디네이터는 가장 처음으로 그룹에 참여한 클라이언트를 리더로 선출함.
- 리더로 선정된 컨슈머는 partition.assignment.strategy 로 설정한 파티션 할당 전략에 맞춰, 그룹에 파티션을 할당.
- Assignor
    
    컨슈머와 파티션 할당 정책은 컨슈머의 어싸이너에 의해 결정됨.
    
    사실 어떤 assignor를 설정하던 파티션과 컨슈머는 1:1 매핑이 되므로 크게 상관 없음.
    
    - RangeAssignor: 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬하여 할당.(기본 값)
       
        ![Untitled - 2023-02-18T003621 808](https://user-images.githubusercontent.com/25525648/219697906-dada6ea3-1a3e-4f27-98ad-0496180d3f8b.png)

    - RoundRobinAssignor: 모든 파티션을 컨슈머에서 번갈아가면서 할당.
    - StickyAssignor: 최대한 파티션을 균등하게 배분하면서 할당.

### 3. Sync

- 그룹에 참여한 모든 컨슈머는 syncGroup 요청을 그룹 코디네이터에게 보내고, 리더는 파티션 할당 결과를 해당 요청에 포함시킴.
- 그룹 코디네이터는 해당 응답으로 컨슈머에 할당된 토픽, 파티션 정보를 보냄.
- 응답을 받은 컨슈머는 자신에게 할당된 토픽, 파티션 정보를 subscription state에 assign 메서드를 활용하여 업데이트함.

# 오프셋 초기화

## 오프셋 초기화를 하는 이유

- 브로커에서 데이터를 읽기 위해서는 파티션의 초기 오프셋 값이 필요.
- subscription state에 assign 메서드를 통해 할당된 파티션은 초기 오프셋 값이 없음.
- 초기 오프셋 값이 없을 경우, 컨슈머는 컨슈머 코디네이터를 통해 커밋된 오프셋 값을 확인함.

## 종류

1. 커밋된 오프셋이 있는 경우
2. 없는 경우

### 커밋된 오프셋 있는 경우

- 컨슈머 코디네이터는 offsetFetch API 를 통해 그룹 코디네이터에게 커밋된 오프셋 정보를 요청
- 그룹 코디네이터는 응답으로 커밋된 오프셋 정보를 알려줌
- 컨슈머 코디네이터는 응답으로 가져온 커밋된 오프셋 정보를 subscriptionState에 업데이트함.
- 업데이트 된 오프셋 값은 fetcher에 의해 파티션의 오프셋 초기값으로 설정됨.

### 없는 경우

- **auto.offset.reset** 설정에 따라 오프셋을 초기화 함.
- fetcher는 파티션의 가장 처음 오프셋과, 마지막 오프셋을 알기 위해, 파티션 리더 브로커로 timestamp에 해당하는 오프셋을 조회하는 ListOffsets API를 활용함.
- 응답으로 받은 오프셋 값은 SubscriptionState의 seek 메서드를 통해 파티션의 초기 오프셋으로 설정됨.

# 오프셋 커밋

- 컨슈머는 브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록
- 컨슈머 동작 이슈가 발생하여 __consumer _offsets 토픽에 어느 레코드까지 읽어갔는지 오프셋 커밋이 기록되지 못했다면 데이터 처리의 중복이 발생할 수 있음.
- 따라서 데이터 처리의 중복이 발생하지 않게 하기 위해, 컨슈머 애플리케이션이 오프셋 커밋을 정상적으로 처리했는지 검증해야 한다.
![Untitled - 2023-02-18T003543 040](https://user-images.githubusercontent.com/25525648/219697838-e273388d-5500-43c0-a34f-9167d22d952f.png)


### 파티션을 신중하게 설정해야하는 이유

파티션에 저장된 데이터 파일은 2개로 원본 데이터와 인덱스 데이터인데,

1. 파티션내에 모든 파일 핸들러를 열어야하므로 **리소스 낭비의 문제**가 있을 수 있습니다.
2. 파티션이 많을 수록 **복구 시간이 증가합니다**.

첫번째로 카프카 브로커가 죽었을 때, 이 브로커가 1000개의 파티션에 대한 리더라고 가정합니다. 그렇다면 리더를 새로 선출할 때까지 데이터를 읽을 수도 쓸수도 없기에 새로운 리더를 선출해야합니다.만약 파티션 하나에 대해 리더를 선출하는 시간이 5밀리초라고 가정했다면, 장애 복구 시간은 5초가 걸립니다.

### 파티션 개수를 선택할 때 유의할 점

- 토픽의 목표 처리량을 컨슈머 예상 처리량으로 나누는 방법으로 파티션 수를 계산할 수 있습니다. 예를 들어 초당 1GB로 토픽을 읽고 쓰길 원하는데 한 컨슈머가 초당 50MB만 처리할 수 있다면 최소한 20개의 파티션이 필요하다는 것을 알 수 있습니다.

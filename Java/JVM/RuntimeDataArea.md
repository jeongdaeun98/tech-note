# Runtime Data Area

✅ 구성 요소

✅ PC 레지스터

✅ JVM 스택

✅ 네이티브 메서드 스택

✅ 힙

✅ 메서드 영역

✅ 런타임 상수 풀

---

![image](https://github.com/uneap/tech-note/assets/25525648/81a22dac-3418-4f6e-97c9-ba690b8a699b)


## PC 레지스터

- 스레드가 시작될 때 생성되는 공간으로, 스레드마다 하나씩 존재함.
- 스레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 **JVM 명령의 주소**를 갖는다.

## JVM 스택

- 스레드가 시작될 때 생성되는 공간, 스레드마다 하나씩 존재함.
- 스택 프레임이라는 구조체를 저장하는 스택
- 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
- 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장한다.
- 메소드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성된다.

## 네이티브 메서드 스택

- Java 외의 언어로 작성된 네이티브 코드를 위한 스택.
- Java Native interface(JNI)를 통해 호출하는 C/C++ 코드를 수행하기 위한 스택으로 언어에 맞게 스택이 생성된다.

## 힙

- **인스턴스 또는 객체를 저장하기 위한 공간**으로 가비지 컬렉션 대상이다.
- JVM 성능 이슈에서 가장 많이 언급되는 공간이다.
- 힙 구성 방식이나 가비지 컬렉션 방법은 JVM 벤더(JVM 공급자)들의 재량이다.

![image (1)](https://github.com/uneap/tech-note/assets/25525648/0d4ceefe-5f4f-4386-b187-e485424de113)


힙은 세 영역으로 나눌 수 있다.

**Permanent Generation**

<aside>
💡 사실 상 힙에 포함되어있다고 하기 어렵고, 별개의 영역인 거 같음…

</aside>

생성된 객체들의 정보의 **주소값이 저장된 공간**이다. 

**Class loader에 의해 load되는** Class, Method 등에 대한 **Meta 정보가 저장되는 영역**이고 **JVM에 의해 사용**된다.

 Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다.

내부적으로 Reflection 기능을 자주 사용하는 Spring Framework를 이용할 경우 이 영역에 대한 고려가 필요하다.

- 메타 데이터란?
    
    클래스 이름, 생성자 정보, 필드 정보, 메소드 정보
    

[JDK8 에서 perm 영역이 삭제된 이유](https://www.notion.so/JDK8-perm-dfb2d67416cd4f11a7ae9d16ec9f071d?pvs=21)

**New/Young 영역**

- **Eden** :
    - **새롭게 생성한 객체** 대부분이 여기에 위치
    - 대부분이 금방 **접근불가능** 상태가 되며, 매우 많은 객체가 Young 영역에 생성되었다가 사라짐
    - 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말함.
- **Survivor 0 / 1** :
    - Eden영역에서 minor GC가 일어났을 경우, 참조되고 있는 게 확인되었을 때 여기에 위치

**Old 영역**

- 접근 불가능 상태로 되지 않아 age가 계속 쌓여 특정 age만큼 쌓였을 때, young 영역에서 살아남은 객체는 여기로 복사 됨.
- 대부분 young 영역보다 크게 할당함.
- 쉽게 가득차지 않기에 GC가 적게 발생함.

## 메서드 영역**(= Class area = Static area)**

- 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성됨.
- 클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장**하기 위한 메모리 공간.
- JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 메서드에 대한 정보, Static 변수, 메서드의 바이트 코드 등을 보관.
- 사실상 컴파일 된 바이트코드의 대부분이 메소드 바이트코드이기 때문에 거의 모든 바이트코드가 올라간다고 봐도 상관없다.
- 이 공간에는 **Runtime Constant Pool**이라는 별도의 관리 영역도 함께 존재한다.
- 이는 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행한다.
    - ***올라가는 정보의 종류***
        
        **1) Field Information**
        
        **멤버변수**의 이름, 데이터 타입, 접근 제어자에 대한 정보
        
        **2) Method Information**
        
        **메소드**의 이름, 리턴타입, 매개변수, 접근제어자에 대한 정보
        
        **3) Type Information**
        
        class인지 interface인지의 여부 저장 /Type의 속성, 전체 이름, super class의 전체 이름(interface 이거나 object인 경우 제외)
        

## **Runtime Constant Pool**

- 각 클래스와 인터페이스의 상수 뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블
- 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조.

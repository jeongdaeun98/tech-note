### JIT 컴파일러 내부

JIT 컴파일러는 두가지 형태로 나뉜다. 

흔히 c1(클라이언트 컴파일러)와 c2(서버 컴파일러)라는 이름으로 부른다.

두 컴파일러의 주요 차이점은 컴파일을 누가 더 많이 하느냐와 방식이다.

### 클라이언트 컴파일러

- 서버 컴파일러보다 먼저 컴파일을 시작한다.
- 1~3 레벨 코드를 컴파일한다.
- 최적화를 위한 대기 시간이 짧다.
- 코드 분석과 컴파일 시간이 서버 컴파일러보다 빠르다.
- 메모리도 더 적게 사용할 수 있다.

### 서버 컴파일러

서버 컴파일러는 런타임에 바이트 코드를 기계어로 변환 하고, 캐시에 저장하는 과정을 수행한다.

즉, 클라이언트 컴파일러는 코드 분석이 빠르고, 최적화를 위한 대기 시간, 서버 컴파일러는 최적화에 중점을 두기에 실행이 더 빠르다.

클라이언트 컴파일러는 서버 컴파일러보다 상대적으로 더 많은 코드를 컴파일하는데,

서버 컴파일러보다 먼저 컴파일하기 시작한다.

그리고 서버 컴파일러는 캐시에 저장하는 과정을 수행하므로, 컴파일할 때, 캐시에 있는 정보를 바탕으로 컴파일을 하기 때문에 상대적으로 클라이언트 컴파일러보다 더 빠르다.

| 컴파일러 종류 | c1 | c2 |
| --- | --- | --- |
| 수행 과정 | compile | compile + cache |
| 컴파일에 대한 적극성 | 1~3레벨 코드 | 4레벨 코드 |

각각의 컴파일러의 트레이드 오프는 프로그램이 수행되는 기간과 초기 스타트업 시간의 중요도를 바탕으로 선택한다.

## 티어드 컴파일 레벨

티어드 컴파일러는 클라이언트와 서버 컴파일러의 장점을 조합한 컴파일러다.

먼저 클라이언트 컴파일러로 스타트업 시간을 빠르게 하고, 많이 쓰이는 부분을 서버 컴파일러로 재컴파일하는 방식을 사용한다.

- server -xx:+TieredCompilation 옵션으로 사용 가능하다.
- 0: 인터프리트된 코드
- 1: 단순 C1 컴파일된 코드
- 2: 제한된 C1 컴파일된 코드
- 3: 전체 C1 컴파일된 코드
- 4: C2 컴파일된 코드

대부분의 메소드는 3레벨인 전체 C1 컴파일된 코드로 처음 컴파일 된다.

모든 메소드는 0레벨부터 시작하며, 빈번하게 수행된다면 3레벨을 거쳐 4레벨에서 컴파일 될 것이다.

만약 서버 컴파일러 큐가 가득차, 4레벨의 컴파일이 불가능하다면 프로파일 피드백을 필요로 하지 않는 2레벨에서 컴파일될 것이다.

그 후 프로파일 정보를 모은 후 C1 컴파일러가 3레벨에서 컴파일 하고, 서버 컴파일러 큐가 덜 바빠지면 4레벨에서 컴파일 된다.

또한 클라이언트 컴파일러 큐가 가득차면 3레벨에서 컴파일 될 예정인 메소드가 4레벨 컴파일 대상이 될 수 있는데, 바로 2레벨로 컴파일 된 후 4레벨로 넘어갈 수 있다.

그리고 코드가 역최적화 될 때 0레벨로 간다.

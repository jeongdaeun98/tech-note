자바는 바이트 코드로 한번 컴파일하는 과정과, 바이트 코드를 인터프리터 하는 방식 2가지를 진행함.

따라서 일반적으로 순수 컴파일만 하는 방식보다는 느림.

![Untitled](https://github.com/uneap/tech-note/assets/25525648/83684b5b-888f-4361-a7c3-1f61627efe49)


## C언어에 비해 자바가 느리다고 하는 이유와 개선 방안 - 인터프리팅 측면, JIT 컴파일러

자바 컴파일러(javac)가 컴파일 타임에 자바 소스에서 바이트 코드로 변환시키는데, 이 때 바이트 코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된다. 

그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

이 때 인터프리터를 사용하여 런타임 시 한줄 씩 읽기 때문에 

런타임 전 소스코드를 미리 읽어서 기계어로 변환하는 방식의 컴파일러보다는 느릴 수 밖에 없다.

이런 문제를 개선해주는 것이 **JIT 컴파일러**이다.

**번역된 코드를 캐싱**해둔 후, 똑같은 코드가 있을 경우 캐싱 해둔 값을 사용하여 매번 번역하는 것을 방지해 인터프리팅 시간을 단축시킨다.

JVM이 호출되는 메서드 각각에 대해 호출마다 **호출 횟수를 누적**해서 (컴파일 임계치)

 그 횟수가 특정 수치를 초과할 때 컴파일한다.

### 컴파일 임계치

- method entry counter(JVM 내에 있는 메서드가 호출된 횟수)
- back-edge loop counter(메서드가 루프를 빠져나오기까지 돈 횟수)

두 카운터의 합계를 확인 후 메서드가 컴파일 될 자격이 있는지 결정

메서드가 컴파일 될 자격이 있다면 해당 메서드는 컴파일 되기 위해 큐에서 대기하게 된다.

그러면 이 메서드들은 이후 컴파일 스레드에 의해 컴파일 된다.

## 속도

JVM의 핵심이며, JVM 내에서 컴파일러보다 성능에 영향을 주는 요소는 없다.

다행스럽게 대부분의 상황에서 티어드 컴파일을 사용하기만 해도 튜닝할 필요는 거의 없다.

티어드 컴파일을 이용하면 코드는 먼저 클라이언트 컴파일러로 컴파일 되고 많이 쓰이게 되면 역최적화 후 서버 컴파일러로 재컴파일 된다.

재컴파일 되는 시간은 성능에 영향을 줄 정도로 크지 않다.

[https://velog.io/@youngerjesus/자바-JIT-컴파일러](https://velog.io/@youngerjesus/%EC%9E%90%EB%B0%94-JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)

https://beststar-1.tistory.com/3?category=975450
https://kotlinworld.com/307

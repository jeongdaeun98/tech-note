# Java
![image](https://user-images.githubusercontent.com/25525648/116489446-efcfc600-a8cf-11eb-80cf-95df2cb47cd3.png)
## 자바 프로그램 실행 과정
1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환 시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 로딩한다.
4. 로딩된 class파일들은 Execution engine을 통해 해석된다.
5. 해석된 바이트코드는 Runtime Data Areas 에 배치되어 수행이 이루어지게 된다.
이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행한다.

## JVM 구조
1. Class loader: JVM 내로 클래스파일을 로드하고 링크하는 작업을 수행하는 모듈이다.
2. Execution engine: 클래스를 실행시키는 역할을 한다.자바 바이트 코드를 실제로 JVM 내
부에서 기계가 실행할 수 있는 형태로 변경한다
3. JIT(Just In Time): 인터프리터 방식의 단점을 보완하기 위해 도입된 컴파일러다. 인터프리
터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변 경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네 이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다. JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하 고, 일정 정도를 넘을 때에만 컴파일을 수행한다.
4. Garbage collector: GC를 수행하는 모듈이 있다.
5. Runtime Data Area
1. PC Register: Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하 는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.
2. JVM 스택 영역: 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바 로 소멸되는 특성의 데이터를 저장하기 위한 영역이다. 메서드 호출시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성된다. 메서드 수행이 끝나면 프레임 별로 삭제를 한다.
3. Native method Stack: 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실 제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다 른 언어로 작성된 코드를 위한 공간이다.
4. Method Area: 클래스 정보를 처음 메모리 공간에 올릴 때 초기화 되는 대상을 저장하 기 위한 메모리 공간이다. 올라가는 정보의 종류로는 멤버변수의 이름, 데이터 타입, 접 근 제어자에 대한 정보 등이 있다.
5. 힙영역: 객체를 저장하는 가상 메모리 공간이다. New 연산자로 생성된 객체와 배열을 저장한다.
## Garbage Collector

### 가비지 컬렉션은 어떤 원리로 소멸시킬 대상을 선정하는가?
- 가비지 컬렉터는 힙 내의 객체 중에서 가비지(참조되고 있지 않은 객체)를 찾아내고 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.
- 객체가 가비지인지 아닌지를 판단하기 위해 reachability라는 개념을 사용한다.
    - 어떤 힙 영역에 할단된 객체가 유효한 참조가 있으면 reachability 없다면 unreachability로 판단한다.
- 하나의 객체는 다른 객체를 참조하고, 다른 객체는 또 다른 객체를 참조할 수 있기 때문에 참조 사슬이 형성되는데, 이 참조 사슬 중 최초에 참조한 것을 root set이라 칭한다.
- 힙 영역에 있는 객체들은 총 4가지 경우에 대한 참조를 하게 된다.
1. 힙 내에 다른 객체에 의한 참조
2. java 스택, 즉 java 메서드 실행시에 사용하는 지역변수와 파라미터들에 의한 참조
3. 네이티브 스택에 의해 생성된 객체에 대한 참조
4. 메서드 영역의 정적 변수에 의한 참조

**2,3,4는 root set이다.**

### GC과정

![](https://i.imgur.com/I5j0JPu.png)

#### Minor GC
- 새로 생성된 대부분의 객체는 Eden 영역에 위치한다. Eden 영역에서 GC가 한번 발생 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
- 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 일정시간 참조되고 있다는 뜻이므로 old 영역으로 이동한다.

#### Major GC
- old 영역에 있는 모든 객체들을 검사하여 참조되지 않은 객체들을 한꺼번에 삭제한다.
- 시간이 오래 걸리고 실행 중 프로세스가 정지된다.(stop the world)
- major gc가 발생하면 gc를 실행하는 스레드를 제외한 나머지 스레드는 모두 작업을 멈춘다.
- GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다.


## G1 GC & Parallel GC
- 라이브 데이터가 많은 경우 G1 GC가 적합

## 오버라이딩 vs 오버로딩
오버 라이딩이란 상위 클래스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의 하는 것을 의미한다.

오버 로딩은 상위 클래스의 메소드와 이름, return type은 동일하지만, 매개변수만 다른 메소드를 만드는 것을 의미한다. 다양한 상황에서 메소드가 호출될 수 있도록 한다.

## Enum 특징

Enum은 서로 연관된 상수들의 집합이라 할 수 있다.

Enum의 타입에는 static 으로 선언된 객체들을 포함할 수 있다.

## Static 메소드 특징

static 메소드는 컴파일 시, 메모리에 올라가고 메소드 영역에 존재하며, 컴파일 시점에 선언된 타입의 메소드를 호출한다.

### **1 모든 인스턴스에 공통으로 사용하는 것에 `Static`을 붙인다.**

생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 Static을 붙여서 클래스 변수로 정의해야 한다.

### **2.Static method는 인스턴스를 생성하지 않아도 사용할 수 있다.**

`Static`이 붙은 메서드는 **클래스가 메모리에 올라갈 때 자동으로 생성**되기 때문이다.

### **3. Static method는 인스턴스 변수를 사용할 수 없다.**

→ `인스턴스 변수 없이(관계없이) 매개변수만으로 작업`

Static method는 인스턴스 생성 없이 호출 가능하므로**Static method가 호출되었을 때, 인스턴스가 존재하지 않을 수도 있다.따라서, Static method에서 인스턴스 변수를 사용해서는 안된다.**

이와 반대로,Instance method에서는 **`Static`이 붙은 멤버들을 사용하는 것이 언제나 가능하다.**(인스턴스 변수가 존재한다는 것은 Static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문)

### **4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, `Static`을 붙이는 것을 고려해보자.**

메서드 안에서 인스턴스 변수를 필요로 한다면, Static을 붙일 수 없다.반대로 인스턴스 변수를 필요로 하지 않는다면 Static을 붙이자. 메서드의 호출시간이 짧아지므로 성능이 향상된다.

### **Static 메서드가 되면 호출 시간이 짧아지는 이유?**

Static을 안 붙인 메서드(인스턴스 메서드)는 실행 시,호출되어야 할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.

## 쓰면 안되는 이유

1. static은 메모리 자원을 할당해놓고 사용하는 것이기 때문에 너무 많이 사용한다면 메모리를 많이 차지하게 되어서 프로그램이 무거워진다.
2. 만약 이 두 카피가 동일한 static 변수를 공유하게 된다면, 서로의 상태에 영향을 주게 되지 않을까요? 더불어서 오버라이딩을 할 수 없는 static 멤버들 때문에 클래스를 확장하는게 어려워질 것입니다. 뿐만 아니라 지나치게 많은 static 변수를 사용하게 되면 이들로부터 메모리 회수를 할 수 없어서 가상머신이 메모리 부족을 겪게 될 것입니다.

→ **메소드 영역:함수영역으로 각 클래스 또는 인터페이스에 런타임 컨텍스트 풀영역, 메소드 생성자를 저장하는 영역으로 모든 스레드에 의해서 공유되는 영역 입니다. 메소드의 컴파일된 바이트코드, static 변수가 저장되는 시점이 클래스가 메모리에 올라가는 시점이다.**

그렇다면 static을 사용하게 되면 해당 객체가 JVM에 메소드(static) 영역에 올라오게 되는데 메소드 영역은 모든 thread에 의해 공유되는 영역이기에 AdClient를 공유하게 된다. 그렇지만 이미 FeignClient는 Singleton 빈으로써 Container에 의해 static 객체로 생성된 후 의존성 주입하는데 굳이 enum을 통해 한번 더 메모리에 저장되는 것이므로 문제가 생기는 건가?
Q 1. static 메소드의 파라미터는 어디에 저장되는 것일까?
스택영역에 저장됨

```json
/** Cache of singleton objects: bean name to bean instance. */ 
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
```

1. **static 함수 모음 클래스의 모든 함수는 인자가 동일할 경우 항상 동일한 결과를 리턴해야 한다. 이 규칙을 지킬 수 없으면 POJO Bean으로 만들라.**
2. **이것이 이뤄지려면 함수 안에서는 외부 자원(Resource)에 대해 하나도 의존하면 안된다는 선결 조건을 충족**
    
    → 그렇지만 static 변수에 빈 객체를 주입하는 방법 중, 하나가 @PostConstruct 선언을 통해 주입하는 것인데, 이는 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250 라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.

- 결합도와 응집도의 차이
    - 결합도는 서로 다른 객체들간의 상호 의존 정도
        - 결합도가 낮을 수록 의존성이 낮아져 수정 및 유지보수, 재사용성이 쉬워짐
    - 응집도는 객체 내부의 구성요소들의 기능적 관련성
        - 응집도가 높을 수록 (하나의 책임에 집중하고) 객체간의 독립성이 높아지고, 재사용성, 수정 및 유지보수가 쉬워짐
- 객체지향 프로그래밍과 장점
    - 객체 지향 프로그래밍이란 프로그래밍에 필요한 데이터들을 추상화하여 상태와 행위를 가진 객체를 만들고, 그 객체들간의 상호작용을 로직으로 구현한 프로그래밍 기법
    - 다형성, 상속을 통해 다양한 기능을 구현할 수있게 하고, 캡슐화를 통해 응집도를 높여 재사용성, 유지보수성, 수정을 쉽게 함. 추상화를 통해 핵심을 강조하고자 복잡한 부분을 단순화시켜 동일한 목적으로 동일한 기능을 보장함.
- 객체지향 프로그래밍의 특징
    - [객체지향의 특징 - 다형성, 상속, 캡슐화, 추상화](https://www.notion.so/9d3ddd35adeb488aa0e43253fb3e78fd?pvs=21)
- 객체지향 설계의 5원칙
    - [객체지향 5원칙 - SOLID](https://www.notion.so/5-SOLID-a64db82c479a490d927fa4e790cb7810?pvs=21)
- JVM 메모리(Runtime Data Area) 구조
    - [Runtime Data Area](https://www.notion.so/Runtime-Data-Area-4837ebd0022b496490817167aa338a23?pvs=21)
- JVM에 runtime data area 내에 힙메모리와 스택 메모리와의 차이점
    - 힙 메모리는 애플리케이션의 모든 부분에서 사용되며, 반면에 스택 메모리는 하나의 스레드가 실행될 때 사용.
    - 그래서 힙 과 메서드 공간에 저장된 객체는 어디서든지 접근이 가능하지만, 스택 메모리는 다른 스레드가 접근할 수 없다.
    - 언제든지 객체가 생성되면 항상 힙 공간에 저장되며, 스택 메모리는 힙 공간에 있는 객체를 참조만 한다.
        - 즉, 스택 메모리는 primitive 타입의 지역변수와 힙 공간에 있는 객체 참조 변수만 갖고 있다.
    - 스택메모리의 생명주기는 매우 짧으며, 힙 메모리는 애플리케이션의 시작부터 끝까지 살아남는다.
    - 자바 코드를 실행할때 따로-Xms과-Xmx 옵션을 사용하면 힙 메모리의 초기 사이즈와 최대 사이즈를 조절할 수 있다.
    - 스택 메모리가 가득차면 자바에서는 java.lang.StackOverFlowError를 발생.
        - 힙 메모리가 가득차면 java.lang.OutOfMemoryError : Java Heap Space 에러를 발생
    - 스택 메모리 사이즈는 힙 메모리와 비교했을 때 매우 적다.
        - 하지만 스택 메모리는 간단한 메모리 할당 방법(LIFO)를 사용하므로 힙 메모리보다 빠르다.
- JVM 메모리(Runtime Data Area) 구조
    - 스레드 당 하나의 영역을 갖는 메모리
        - pc 레지스터
            - 스레드가 수행해야 할 명령어의 주소를 갖고 있는 메모리
        - jvm 스택
            - 원시 타입으로 되어있는 로컬 변수, 매개 변수를 저장
            - 메서드 호출 당 하나의 스택 프레임을 가짐
        - 네이티브 메소드 스택
            - 자바 외의 언어로 이뤄진 코드를 저장하는 스택
    
    스레드가 공유하는 메모리
    
    - 힙영역
        - young 영역(gc 대상)
            - eden, survivor 1, survivor 0 으로 구성
            - suvivor 0/1은 eden 영역에서 gc가 일어났을 때 참조가 있어서 살아남은 객체들이 저장되는 공간
        - old 영역(gc 대상)
            - 지속적인 gc가 발생했을 때에도 참조가 있다고 판단되어 몇번의 생존에서 살아남은 객체들이 모인 공간
            - 저장 공간이 young 영역보다 더 크고, 쉽게 가득차지 않아 gc가 적게 일어난다.
        - jvm7- perm gen jvm8 - meta space
            - gc의 대상이 아닌 힙 영역
            - perm gen은 메타데이터와 static 변수를 저장하고 있다.
            - meta space는 OS에서 관리하는 native space다. 메타 데이터를 저장한다.
            - 메서드 영역(perm gen과 meta space 내부에 있음)
                - 필드 정보, 메소드 정보, 클래스 정보를 포함
                - 대부분의 바이트 코드가 저장되는 영역
                - static 변수 저장
                - runtime 상수 풀
                    - 객체의 주소값을 저장
                    - 자바 프로세스 종료까지 계속 유지되는 메모리 영역
- 변수의 종류와 메모리 구조
    - [static ](https://www.notion.so/static-fac244c5629f4801bfeca08fbb7d13fe?pvs=21)
    - [변수](https://www.notion.so/b9e11e47bc804241bd9139d0815af5c8?pvs=21)
- JVM(Java Virtual Machine)
    - [jvm](https://www.notion.so/jvm-91d4ca87a9794d09878356b1573fde1a?pvs=21)
- Java 프로그램 실행 과정
    - [자바 프로그램 실행 과정](https://www.notion.so/b09315dd14e44d5891e49178ac02ab04?pvs=21)
- 변수의 종류와 메모리 구조
    - static 변수 → 메소드 영역의 런타임 상수 풀
    - 원시타입의 매개변수, 로컬변수 → jvm 스택 영역
    - 객체 변수 → 주소값은 런타임 상수 풀 값 자체는 힙 영역
- 리플렉션이란 무엇인가요?
- JVM이 하는 역할이 무엇인가요?
- 메모리 상수풀 영역에 대해 설명해보세요.
- reflection
    - reflection은 메타데이터를 활용하여 동적으로 메소드 호출 등을 할 수 있다.
    - 사용되지 않은 클래스에 대해 reflection을 통해 조작하는 것을 유의해야 한다. 클래스 로더는 사용되지 않는 클래스에 대해 로딩을 하지 않는데, 이 때 reflection을 위해 메타 데이터가 메모리에 올라오면 OOM이 발생할 수 있으며, jvm8의 경우 잘못하다 서버가 중단될 수 있다.
- Java에서 Garbage Collection이 필요한 이유
    - java는 gc를 통해 메모리 회수를 한다. 참조가 없는 변수의 경우 gc를 통해 메모리 회수되며, 힙 메모리가 gc의 대상이다.
- Garbage Collection 동작 방식
    
    gc가 발생하면 gc를 담당하는 스레드 외에 모든 스레드는 하던 일을 멈춘다. 이 때 stop the world라고 한다. 
    
    1. 새로운 객체가 생성되면 eden 영역에 값이 저장된다.
    2. eden 영역이 가득차면 minor GC가 발생하면서 참조값이 없는 객체는 메모리를 회수하고, 참조 값이 존재하는 객체는 age bit를 증가하면서 survivor0로 이동한다.
    3. survivor 0가 가득차면 minor GC가 발생하면서  살아남은 객체는 age bit가 증가되고, survivor1으로 이동한다.
    4. 이런 방식으로 반복되다가 **age bit**가 threshold를 도달하면, old 영역으로 이동한다. 이를 promotion이라고 한다.
    5. old 영역이 가득차면 major GC가 발생한다. old 영역은 young 영역에 비해 크기가 커서 가득 차는 비율이 적은 편이다. 

---

- 디미터 법칙
    - 캡슐화를 통해 응집도를 높여서 복잡한 기능을 볼 수 없게 하여 하나의 기능으로 집중할 수 있게 하는 법칙.
- CQRS
    - **메소드의** 목적은 요청과 응답 중 하나의 역할만 해야한다는 법칙. 요청은 상태를 변경시킬 수 있지만 값을 반환해서는 안되고, 응답은 상태를 변경시키지 못하지만 값을 반환해야 한다.
- TDA 원칙
    - 물어보지 말고 시켜라 원칙, 즉 getter를 통해 객체의 상태를 직접 확인하지 말고, 상태에 대한 **판단**을 하라고 객체에 시키는 것.
        - ex) 자동차 부품 중 망가진 리스트를 알고자 하는데, 자동차 클래스에 부품 하나하나를 조회하는 게 아니라, 자동차 클래스에서 망가진 부품 리스트 자체를 전달해주는 방식으로 구현해야함.
- Immutable
    - 불변성, 변하지 않는 성질
        
        1. 쓰레드에 안전하여 멀티 쓰레드 환경에서 동기화를 고려하지 않아도 된다.
        
        2. 불변객체를 필드로 사용할 때 방어적 복사가 필요없다.
        
        3. 불변객체는 내부상태가 변경되지 않으므로, Map Key 와 Set 요소로 사용하기에 적합하다.
        
        4. 불변객체를 한번 메모리에 할당하게 되면 같은 객체를 계속 호출하여도, 새롭게 할당하지 않아도 되므로 GC 의 성능을 높힐 수 있다.
        
        불변객체를 생성하기 위한 전략이다.
        
        1. setter 메소드를 사용하지 마라
        
        2. 모든 필드를 final 과 private를 사용해서 선언해라
        
        3. 클래스를 final 로 선언하여 Overriding을 막아라
        
        4. 객체를 생성하기 위한 생성자 혹은 정적 팩토리 메소드(spring에서 알자)를 추가해라
        
        5. 인스턴스 필드에 가변객체가 포함된다면 방어적 복사를 이용하여 전달해라
        
- Access Modifier(접근 제한자)
    - [접근 제어자](https://www.notion.so/733a27cebfa34a62a322bb17fdd03803?pvs=21)

---

- final 키워드
    - https://sabarada.tistory.com/148
    - final은 객체의 재할당을 방지할 뿐, 불변성을 보장할 수는 없다.(arrayList로 초기화해줄 경우, 해당 객체에 데이터를 추가한다면, 변수의 내부 데이터는 달라진다)
- Call by Value vs Call by Reference
    - 자바는 call by value로 값을 복사하여 메소드 호출시 프로퍼티에 전달한다.
    - 객체의 경우, 힙 메모리에 저장된 값을 참조하는 새로운 주소값을 스택 메모리에 저장하여 전달한다.
    - 따라서 메소드 내에서 객체에 새로운 값을 대치시키면, 메소드에서 값을 반환하여 종료되면, 스택에서 주소값은 사라지고 기존에 스택에 있던 주소값이 바라보고 있던 값에는 영향을 주지 않는다.
- Wrapper Class
    - 기본형을 객체로 나타내기위한 클래스이다. null값을 대입할 수 있으며, collection에 해당 타입으로 구성된 객체를 만들 수 있다.
- 기본(원시)형과 참조형의 차이점
    - null값 대입 유무, collection에 해당 타입 데이터 넣을 수 있는지 여부(제너릭), 참조형은 스택에 주소값이 저장되고 값은 힙메모리에 저장되지만, 기본형은 스택에 값이 저장된다.

---

- Overriding과 Overloading
    - 오버라이딩은 자식 클래스가 부모 클래스의 메소드를 물려받아 **기능을 확장**하기 위해 수정하는 것
    - 오버로딩은 매개변수의 타입, 개수를 달리하여 동일한 메소드를 여러개 만들어서 **활용도를 높이는** 것
- Casting
    - 업캐스팅은 자식 클래스가 부모 클래스로 형변환되는 것
        - 부모 클래스의 static 메서드에 접근할 수 있음.
        - 부모 클래스의 메소드를 오버라이딩한 메소드에 접근할 수 있음.
        - 그러나 자식 클래스 고유의 **멤버 변수**에 접근할 수 없음.
    
    ```java
    Child child = new Child();
    Parent p = child;
    ```
    
    - 다운 캐스팅은 부모 클래스가 자식 클래스로 형변환 되는 것.
        - 하위클래스로 변환하기 위해서는 명시적으로 타입을 지정해야 한다.
        - 자식 클래스 고유의 성질을 갖게 되어 **모두 접근**할 수 있음.
    
    ```jsx
    Parent parent = new Parent();
    Child child = (Child)parent;
    ```
    
- Promotion과 Casting
    - 프로모션은 묵시적 형변환으로 작은 타입은 더 큰 타입으로 형변환 됨.
        - int a는 long으로 프로모션 가능
    - 캐스팅은 명시적 형변환으로 큰 타입이 작은 타입으로 변환되려면 타입을 명시해야 함.
- 다형성에 대해서 설명해보세요
    - 하나의 클래스나 메소드가 다양한 방법으로 구현되어 사용되는 것을 의미함.
        - 추상화 클래스나 추상화 메소드 등으로 선언되었을 때, 하위 클래스가 자신의 목적에 맞게 구현하는 것을 말한다.
- 박싱과 언박싱에 대해 설명하세요
    - 원시형을 Wrapper Class로 변환하는 것이 박싱이고,Wrapper Class를 원시형으로 변환하는 것이 언박싱
- 동적바인딩과 정적 바인딩
    - 동적 바인딩은 런타임 시간에 객체 타입을 기준으로 실행될 함수를 호출하는 것
    - 정적 바인딩은 컴파일 시간에 객체의 타입을 기준으로 실행될 함수를 호출하는 것
- non-static과 static 멤버의 차이
    - static 변수는 메서드 영역에 저장되며, 클래스 하나 당 단 하나의 변수만 생성된다.
        - 전역으로 접근할 수 있으며 프로그램이 종료되어야 static 변수가 소멸한다.
    - non static 변수는 stack이나 heap 메모리에 할당된다. 객체 하나 당 하나의 변수로 생성된다. 즉, 객체가 여러개면 변수도 여러개가 메모리에 할당된다.
        - 전역이 아니며, 객체만이 접근할 수 있다. **객체 소멸 시 변수도 소멸된다.**

[[ Java ] 08. JAVA의 형변환(Promotion, Casting)](https://coder-in-war.tistory.com/entry/Java-08-JAVA의-형변환Promotion-Casting)

[[JAVA] 정적 바인딩(Static Binding) vs 동적 바인딩(Dynamic Binding)](https://sorjfkrh5078.tistory.com/87)

---

- 제너릭이 무엇인가요?
    - 클래스를 선언할 때 타입을 결정하지 않고 객체 생성 시 유동적으로 재사용하기 위한 것
    - 다양한 타입을 필요로 하는 클래스나 메소드를 구현할 때 사용함
    - 제너릭을 활용하면 따로 형변환할 필요가 없고, 컴파일 시 타입 체크를 하여 타입 에러가 발생하지 않음
- 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명하세요
    - 컬렉션 클래스에서 제너릭을 사용하면, 컬렉션 클래스에 저장되는 인스턴스 타입을 제한하여 타입에러를 컴파일 타임에 잡아낼 수 있도록 도와주기 때문에 사용합니다.
- pojo가 무엇인가요?
    - 특정한 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 말한다.
- 자바의 클래스 멤버 변수 초기화 순서에 대해 설명하세요
    - **멤버 변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.**
    - 클래스 변수는 항상 인스턴스 변수보다 먼저 생성되고 초기화된다.
    - 클래스 변수는 클래스가 처음 로딩될 때 단 한번 초기화된다.
    - 클래스가 처음 로딩될 때, 클래스 로더는 링킹 단계에서 클래스에 필요한 메모리 할당하면서 클래스 변수에 기본값으로 초기화한다.
    - 초기화 단계에서 명시적 초기화 한다.
    - 그 후 클래스 초기화 블록이 클래스 변수들을 초기화한다.
    - 인스턴스 변수는 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.
    - 클래스 변수와 인스턴스 변수 초기화는 원시 타입일 경우, 기본값인 0으로 초기화가 먼저 이뤄진다. 객체타입일 경우, 기본값인 null로 초기화가 이뤄진다.
    - 그 후 클래스 변수의 초기화는 명시적 초기화,  클래스 초기화 블록 순으로 이뤄진다.
    - 인스턴스 변수의 초기화는 명시적 초기화, 인스턴스 초기화 블록, 생성자 순으로 이뤄진다.
    - 명시적 초기화는 변수를 선언과 동시에 초기화하는 것이다.
    
    ```jsx
    class InitBlock {
       static {/* 클래스 초기화블럭 입니다. */}
       {/* 인스턴스 초기화블럭 입니다. */}
    }
    ```
    
    ---
    
- jdbc가 무엇인가요?
    - 자바에서 데이터베이스를 접속할 수 있도록 해주는 자바 API입니다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법들을 제공합니다.
- 직렬화란 무엇인가요 ?
    - 객체를 스트림으로 입출력하기 위해서 바이트 배열로 변환하는 것을 직렬화
    - 반대로 스트림으로 받은 직렬화된 객체를 다시 원래로 돌리는 건 역직렬화
    - 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동
    - 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 저장하거나 네트워크로 전송하는 것이 불가능
- serialVersionUID를 선언해야 하는 이유는 뭔가요?
    - JVM은 직렬화나 역직렬화를 하는 시점의 클래스에 대해 version 번호를 부여함.
    - 클래스의 정의가 바뀌거나 컴파일러 버전이 다르면, version 번호도 새롭게 할당함.
    - 직렬화와 역직렬화의 version 번호가 서로 다르면 안되기 때문에 serialVersionUID를 선언해서 문제를 해결
    - 클래스 버전이 맞는지 확인하기 위한 용도
    - serialVersionUID를 만드는데 참조하는 요소
        
        1. 클래스 이름 (fully qualified)
        
        2. 클래스의 접근 제한자 (public, final, abstract, 또 interface 여부)
        
        3. 각 멤버 필드의 시그너처 (이름과 접근 제한자, 타입)
        
        4. 각 멤버 메소드의 시그너처 (이름과 접근 제한자, 각 인자별 정보, 리턴 타입)
        
        4. 각 생성자의 시그너처 (접근 제한자, 각 인자별 정보)
        
        5. static initializer block 존재 유무
        

---

- 인터페이스가 뭐죠? 왜 사용하나요?
    - 인터페이스는 모든 메서드가 추상 메서드로 이루어진 클래스
    - 특징으로는 따로 abstract를 쓰지 않아도 모두 추상 메서드로 정의
    - 선언한 변수는 자동으로 final static 키워드가 붙음.
    - 사용하는 이유는 예를 들면.. 인터페이스는 팀 작업을 할 때 개발코드와 객체가 서로 통신하는 접점 역할을 지원합니다. 개발코드에서는 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알면 다른 팀의 작업을 기다리지 않아도 됩니다. 또한 해당 객체가 수정이 되더라도, 개발 코드 부분은 수정하지 않아도 되는 장점도 있습니다. 이처럼 인터페이스를 통해 팀 단위로 큰 프로젝트를 효율적으로 진행할 수 있습니다.
- 추상 클래스와 인터페이스
    - [추상 클래스와 인터페이스](https://www.notion.so/bc81126815ef419a96938e6a826aa125?pvs=21)

---

- 상속과 컴포지션(합성)의 차이에 대해서 설명해보세요
    
    
    |  | 상속 | 합성 |
    | --- | --- | --- |
    | 의존성 | 컴파일 타임으로 클래스 사이의 의존성 | 런타임으로 객체 사이의 의존성 |
    | 관계 | is-a 관계 | has-a 관계 |
    | 재사용 명칭 | 화이트 박스 재사용 | 블랙 박스 재사용 |
    
    상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되므로 화이트 박스이다.
    
    합성은 객체 내부는 공개되지 않고 인터페이스를 통해서만 재사용되므로 블랙박스 재사용이다.
    
    **합성**
    
    객체 간의 계층 관계를 표현하고자 하는 것이다. 
    
    이 방식은 코드 재사용을 목적으로 상속하는 게 아닌, 객체 간의 계층 관계를 표현하는 것이 주 목적이다.
    
    코드 재사용은 부수 효과로 따라오는 것이다.
    
    합성과 인터페이스 상속을 하게 되면, 클래스 폭탄을 막을 수 있다.
    
    **클래스 상속**
    
    코드 재사용을 목적으로 하는 상속이다.
    
    부모와 자식 간의 결합도가 매우 높아, 개방-폐쇄 원칙을 위배한다.
    
    → 부모의 코드를 수정하기 위해 자식의 코드도 확인해야하며, 알지 못하는 부수 효과가 있을 수 있다.
    
    또한 기능을 추가하기 위해서는 부모의 자식들과 비슷한 코드를 한묶음 추가해야한다.
    
- 상속과 인터페이스의 차이
    - 상속은 부모클래스의 메소드나 상태를 물려받아 자식클래스가 재사용하거나 기능 확장을 시킬 수 있다.
    - 제대로 만들어진 상속 설계는 자식 클래스가 부모클래스와 is a kind of 관계를 만족한다.(일반적인 개념과 구체적인 개념의 관계)
    - 인터페이스는 기능 구현을 강제하여 메소드를 동일한 동작으로 표준화시켜 서로다른 클래스를 상호작용할 수 있게 한다.
    - 재대로 만들어진 인터페이스 설계는 has a 관계를 만족해야 한다.(포함의 관계)
- 클래스와 인스턴스의 차이
    - 클래스는 객체를 만드는 틀, 기능과 상태를 정의함.
    - 객체는 클래스라는 틀로부터 만들어진 실체, 기능(메소드)과 상태(변수)의 집합.
- 상속과 컴포지션(합성)의 차이에 대해서 설명해보세요
    
    **합성**
    
    객체 간의 계층 관계를 표현하고자 하는 것이다. 
    
    합성은 객체 내부는 공개되지 않고 인터페이스를 통해서만 재사용되므로 블랙박스 재사용이다.
    
    런타임으로 객체 사이의 의존성이 있으며, 구현체 has a 인터페이스 관계로 설계되어야 한다.
    
    이 방식은 코드 재사용을 목적으로 상속하는 게 아닌, 객체 간의 계층 관계를 표현하는 것이 주 목적이다.
    
    코드 재사용은 부수 효과로 따라오는 것이다.
    
    합성을 하게 되면, 클래스 폭탄을 막을 수 있다.
    
    **클래스 상속**
    
    코드 재사용을 목적으로 하는 상속이다.
    
    상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되어 재사용되므로 화이트 박스 재사용이다.
    
    컴파일 타임으로 클래스 사이의 의존성이 있으며,
    
    자식 클래스 is-a 부모 클래스관계를 지키도록 설계되어야 한다.
    
    부모와 자식 간의 결합도가 매우 높아, 개방-폐쇄 원칙을 위배한다.
    
    → 부모의 코드를 수정하기 위해 자식의 코드도 확인해야하며, 알지 못하는 부수 효과가 있을 수 있다.
    
    또한 기능을 추가하기 위해서는 부모의 자식들과 비슷한 코드를 한묶음 추가해야한다.
    
- 클래스 로더란
    
    자바는 런타임에 클래스를 로드하고 링크하는 특징이 있다.
    
     클래스 로더는 JVM의 Method 영역에 동적으로 Java 클래스를 로드하는 역할을 한다.
    
- 클래스 로더의 동작방식
    1. JVM의 Method Area에 클래스가 로드되어 있는지 확인한다. 만일 로드되어 있는 경우 해당 클래스를 사용한다.
    2. Method Area에 클래스가 로드되어 있지 않을 경우, 시스템 클래스 로더에 클래스 로드를 요청한다.
    3. 시스템 클래스 로더는 확장 클래스 로더에 요청을 위임한다.
    4. 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임합니다.
    5. 부트스트랩 클래스로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 확장 클래스로더에게 요청을 넘긴다.
    6. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 시스템 클래스 로더에게 요청을 넘긴다.
    7. 시스템 애플리케이션 클래스로더는 시스템 Classpath에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생시킨다.
- 클래스 로더의 세가지 원칙
    - 위임 원칙
        - 클래스 로더는 클래스 또는 리소스를 찾기 위해 요청을 받았을 때, 상위 클래스 로더에게 책임을 위임하는 위임 모델을 따른다.
    - 가시 범위 원칙
        - 하위 클래스로더는 상위 클래스로더가 로드한 클래스를 볼 수 있지만, 반대로 상위 클래스로더는 하위 클래스로더가 로드한 클래스를 알 수 없다
        - java.lang.Object 클래스 등 상위 클래스 로더에서 로드한 클래스도 하위 클래스 로더인 시스템 클래스 로더 등에서 사용할 수 있다. 그러나 상위 클래스 로더에서 하위 클래스 로더가 로드한 클래스를 사용할 수 없다.
    - 유일성의 원칙
        - 하위 클래스 로더가 상위 클래스 로더에게 로드한 클래스를 다시 로드하지 않아야 한다는 원칙이다.
        - 위임 원칙에 의해서 위쪽으로 책임을 위임하기 때문에 고유한 클래스를 보장할 수 있다.
- 클래스 로더가 어떻게 클래스를 동적으로 로딩하는지
    
    하나의 클래스를 로딩하는 과정에서 동적으로 다른 클래스를 로딩하는 것을 로드 타임 동적 로딩, 클래스를 로딩할 때가 아닌, 리플리케이션을 활용해 **코드를 실행하는 순간에** 클래스를 로딩하는 것을 런타임 동적 로딩이라고 한다.
    
- 클래스 로딩 시점
    - 클래스의 인스턴스 생성
    - 클래스의 정적 변수 사용(컴파일 타임 상수는 x)
    - 클래스의 정적 메소드 호출
- 클래스 초기화 시점
    - 클래스의 인스턴스 생성
    - 클래스의 정적 변수 사용(컴파일 타임 상수는 x)
    - 클래스의 정적 메소드 호출
- final 키워드
    - 변수
        - 객체의 값 자체를 변경할 수 없지만, 객체의 내부 값은 final 키워드의 영역을 벗어나서 수정이 가능하다. 예를 들어 collection 객체인 arrayList를 final로 선언할 경우, arrayList 내부 데이터는 삭제와 추가가 자유롭게 이뤄지지만, 다른 arrayList 객체로 초기화될 수 없다.
    - 메소드
        - 오버라이딩이 불가능하다.
    - 클래스
        - 상속이 불가능하다.
- 싱글톤 패턴과 클래스 로더
    
    JLS(Java Language Specification)에 따르면 JVM에 클래스가 로딩되고 초기화될 때는 순차적으로 동작함을 보장한다. 멀티 스레드 환경에서 여러 개의 스레드가 동시에 클래스를 로딩하려고 하면 오직 한 개의 클래스만 로딩된다.
    
    ```java
    public class HolderSingleton {
    
        private HolderSingleton() {
        }
    
        public static HolderSingleton getInstance() {
            return Holder.instance;
        }
    
        private static class Holder {
            public static final HolderSingleton instance = new HolderSingleton();
        }
    }
    ```
    
    따라서 해당 클래스가 로드되어도 내부 클래스는 로드되지 않는다는 클래스 로더의 특성을 이용한 Holder에 의한 초기화 방식으로 싱글톤 패턴을 구현할 수 있다.
    
    ```java
    class Singleton {
    	private Singleton() {}
    	public static Holder getInstance() {
    	 return	Holder.instance;
    	}
    
    	public static class Holder{
    		public static final Singleton instance = new Singleton();
    	}
    }
    ```
    
- 컴파일 타임 상수, 런타임 상수
    
    컴파일 타임 상수는 static final로 선언된 원시 타입이나 스트링 문자열 값으로 초기화된 상수를 의미하고, 런타임 상수는 static final로 선언된 불변 참조나 random 객체로 선언된 런타임 시 변할 수 있는 값이라 한다. 런타임 상수는 클래스 로더에 의해 클래스가 로드된 후 메모리에 로드되나, 컴파일 타임 상수는 컴파일 시 메모리에 로드된다는 특징이 있다.

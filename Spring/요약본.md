- DI
    - 직접 객체를 생성하여 선언하는 것이 아닌, 객체의 의존성을 주입받는다.(Store-Product: DI, 
    Store-Pencil: DIx) DI가 아닐 땐, 객체와 객체의 관계가 형성되지 않고,클래스와 클래스 간의 관계가 형성되는 단점이 있다. 이 경우, 재사용성이 낮아지고, 유지보수, 수정이 어려워지는 문제가 있다.
    - 예를 들어 핸드폰 기능을 수행하고자 한다면, 그 기능을 가진 기종을 실행시키는 클래스를 따로 따로 만들어야 해서, 생산성도 떨어지고 추후 유지보수도 어려워지는 단점이 있음.
        - 그러나 기능을 인터페이스로 클래스에 선언해두고, 그 기능을 가진 기종을 의존성 주입하면, 따로 만들지 않더라도 하나의 클래스에서 기능을 수행할 수 있고, 유지보수도 쉬워진다.
- IoC
    
    기존 자바 프로그램의 경우, 개발자가 직접 제어함.
    기존엔 클래스간의 의존성을 맺어 결합도가 높아 유지보수가 어려웠다. 또한 개방 폐쇄 원칙을 위반했다.
     클래스 내부에서 다른 객체의 메소드를 사용하고 싶다면, 클래스 내에 다른 객체 선언 후 생성. 그러나 스프링에서는 IOC 제어의 역전으로 어플리케이션 컨텍스트에서 빈 생성과 생명 주기와 설정 정보를 통한 빈 주입을 관리함. 이를 통해, 객체지향 원칙을 지키기 쉬워짐.
    
     인터페이스는 구현을 강제해서 기능에 대해 동일하게 작동하도록 표준화하여 서로 다른 객체들끼리 상호작용할 수 있도록 한다. 객체들간의 의존성을 갖고 있어, 런타임 시점에 의존성이 주입되므로, 변경에 유연한 코드를 작성할 수 있다.
    
- ApplicationContext
    - spring container의 한 종류이며, 빈 팩토리를 확장시켜 AOP등의 기능을 제공하며, 빈 주입과 생명주기를 관리한다. 또한 lazy loading으로 메서드나 클래스가 빈 요청 시에만 객체를 만들고 빈을 로드한다.
- 자바와 스프링 싱글톤
    - 자바에서는 싱글톤이 안티패턴으로 불린다. 자바에서 보편적으로, 싱글톤을 만들기 위해서는 클래스의 생성자를 private으로 만들어서 객체를 새롭게 생성할 수 없게 만든다. 그리고 의존성 주입을 해주는 메소드를 static 메소드로 만들어 전역에서 해당 클래스에 대한 의존성 주입이 가능하도록 만든다.
    - 이와 같은 단점들을 보완한 게 스프링 싱글톤이다.
    - 이 것에는 4가지 단점이 있다.
        1. private 생성자로 만들어져 상속이 어렵다.
            1. 상속은 객체 지향의 특성으로 기능의 확장을 가능하게 한다.
        2. static 메소드로 전역 메소드로 이뤄져 객체 지향의 특성 중 캡슐화를 어긴다.
            1. 캡슐화로 하나의 기능으로 집중하여 독립성을 높이고, 의존성을 낮춰 결합도를 낮추고 응집도를 높여 수정이 용이하고 재사용성이 높은 프로그래밍을 만들 수 있으나 이것을 어렵게 함.
        3. 싱글톤으로 test하기 어렵다.
        4. 서버 환경에서는 한개의 싱글톤이 보장되지 않을 수 있다.
            1. A 스레드는 의존성이 주입되지 않았다고 체크하여 새 의존성을 주입했는데, B 스레드가 A스레드의 의존성 주입 직전에 주입되지 않았음을 체크해서 새 의존성을 다시 주입하는 상황이 발생한다.
- 스프링 빈과 자바 빈
    - 자바 빈은 pojo 객체로, 객체 지향원리에 충실하게 개발되었으며 특정한 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 말한다. 스프링 빈은 application context에 의해 의존성 주입되고, 생명주기가 관리되는 자바 객체를 말한다.
- 스프링 빈 스코프
    - sigleton, prototype이 있는데, 디폴트는 singleton이다. 즉 생성된 객체는 단 한개이며, applicaton context에 의해 빈 주입을 받고, 생명주기를 관리받는다. prototype은 빈 객체 요청할 때 마다 새롭게 생성하며, 생명주기 또한 개발자가 직접 관리해야한다.

---

- 빈의 생명주기
    
    스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료
    
    스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 관리한다.
    
    1. 인터페이스
    
    ```java
    public class ExampleBean implements InitializingBean, DisposableBean {     
    @Override
        public void afterPropertiesSet() throws Exception {
            // 초기화 콜백 (의존관계 주입이 끝나면 호출)
        }
         @Override
        public void destroy() throws Exception {
            // 소멸 전 콜백 (메모리 반납, 연결 종료와 같은 과정)
        }
    }
    ```
    
    - InitalizingBean은 afterPropertiesSet() 메소드로 초기화를 지원한다. (의존관계 주입이 끝난 후에 초기화 진행)
    - DisposableBean은 destory() 메소드로 소멸을 지원한다. (Bean 종료 전에 마무리 작업, 예를 들면 자원 해제(close() 등))
    - 단점
        - InitalizingBean, DisposableBean 인터페이스는 스프링 전용 인터페이스이므로, 스프링 프레임워크에 강한 결합이 생긴다.
        - 초기화, 소멸 메소드를 오버라이드 하기 때문에 메소드명을 변경할 수 없다.
        - 코드를 커스터마이징 할 수 없는 외부 라이브러리에 적용 불가능하다.
    1. 설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")` 처럼 초기화, 소멸 메서드를 지정할 수 있음.
        - 메서드 이름을 자유롭게 줄 수 있음.
        - 스프링 빈이 스프링 코드에 의존하지 않음.
        - 코드가 아니라 설정 정보를 사용하므로 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용 가능.
        
        **종료 메서드 추론**
        
        - @Bean destroyMethod엔 특별한 기능이 있음.
        - destroyMethod는 기본 값이 (inferred)로 등록됨.
        - 이 추론 기능은 close, shutdown이라는 이름의 메서드를 자동으로 호출함.
        - 추론 기능 사용하기 싫으면 destroyMethod="" 처럼 빈 공백을 지정하면 됨.
    2.  @PostConstrouct, @PreDestroy
    - 최신 스프링에서 가장 권장함
    - 스프링에 종속적인 기술이 아닌 자바 표준(JSR-250)임. 다른 컨테이너에서도 동작함.
    - 컴포넌트 스캔과 잘 어울림.
    - 단점
        - 외부 라이브러리에는 적용하지 못함. 외부라이브러리 초기화, 종료하려면 @Bean 설정을 이용하자.
- 스프링 빈 주입 방법
    - 생성자 주입, setter 주입, 필드 주입 등이 있는데, 생성자 주입을 사용하는 것이 좋다.
        - 순환 참조를 방지할 수 있음. 클래스 생성자를 호출하면서 그 필드에 해당하는 빈들의 의존성을 주입하는데, 이 때 순환참조가 있음을 컴파일 단계에서 알 수 있음.
        - final로 객체를 선언할 수 있어 불변성을 유지할 수 있음
- @Bean 과 @Component의 차이
    - 전자는 메소드 레벨에서 등록, 개발자가 수동으로 빈 등록, 후자는 클래스 레벨에서 등록, 스프링이 컴포넌트 스캔을 통해 자동으로 빈 등록

---

- @Configuration
    - bean 등록 시 싱글톤이 되도록 보장
        
        ```java
        @Configuration
        public class Config {
        	@Bean
        	public Bean bean() {
        			return new Bean();
        	}
        }
        ```
        
        - 설정 클래스(AppConfig.class)에서 @Configuration을 삭제한 후, @Bean을 설정 한 뒤, 해당 빈을 요청하면, 스프링 빈으로 등록은 되지만 싱글톤이 유지되지 않는다.
        - Application Context를 통해 AppConfig에서 빈을 가져오는 테스트를 해보면,
        
        ```java
        @Test
        void configurationDeep() {
        	ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
        	Config bean = ac.getBean(Config.class);
        	System.out.println(bean.getClass());
        }
        
        //결과
        class daeun.Config$$EnhacerBySpringCGLIB$$~~~~
        ```
        
    - CGLIB라는 바이트 코드 조작 라이브러리를 통해 AppConfig 클래스를 상속받은 임의의 Proxy 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한다.
        - 해당 프록시 클래스에서의 동작은 다음과 같다.
        - 만일 Bean이 스프링 컨테이너에 등록되어있다면, 스프링 컨테이너에서 찾아서 반환 하고, 없다면 기존 로직을 호출해서 bean 생성하여 스프링 컨테이너에 등록되도록 한 뒤, 반환하는 형식임.
    - 스프링 컨테이너에서 bean을 관리할 수 있게 됨.
- AOP
    - 관점지향 프로그래밍, 모든 코드에 수행되는 로깅 처리나, 성능 테스트와 같은 공통적인 로직으로 묶어서 코드의 앞/뒤에 공통 로직을 수행하도록 처리해 중복 코드를 제거하는 프로그래밍.
    - 프록시 패턴 기반의 AOP 구현체
    
    [[Spring] 스프링 AOP (Spring AOP) 총정리 : 개념, 프록시 기반 AOP, @AOP](https://engkimbs.tistory.com/entry/스프링AOP)
    
- proxy
    
    [프록시 패턴](https://www.notion.so/e3ace8bfe7e34cb2a72f2fa8e50d8c1a?pvs=21) 
    

---

- dynamic proxy
    
    [동적 프록시(Dynamic Proxy) with Spring](https://velog.io/@codemcd/동적-프록시Dynamic-Proxy-with-Spring)
    
- Data source란?
    
    [[Spring DataSource] Connection Pool, DataSource 란?](https://taler.tistory.com/12)
    
- 트랜잭션 동기화 매니저의 역할
    
    [[Spring DB] 트랜잭션 동기화](https://velog.io/@daehoon12/Spring-DB-트랜잭션-매니저)
    
- multi thread
    
    [[Spring] Spring의 Multi Thread, Singleton, Thread-safe](https://fbtmdwhd33.tistory.com/256)
    
- async
    
    [Spring @Async 내부 속으로 (EnableAsync 그리고 AOP)](https://blog.naver.com/gngh0101/222073112894)
    
    [[Spring] @Async 사용 방법](https://steady-coding.tistory.com/611)
    

---

- Maven과 Gradle
    - maven은 라이브러리나 프로젝트 의존성을 pom.xml에 명시
    - gradle은 build.gradle에 라이브러리나 프로젝트 의존성을 명시하며, groovy 언어로 새겨짐.
        - 증분 빌드로, 이전에 빌드된 task의 경우 냅두고, 빌드되지 않은 task만 빌드되는 형태임.
        - build cache가 있어서, 이전에 캐시가 남아있으면 해당 캐시로 빌드 진행함.
- 필터와 인터셉터 차이
    - 필터는 dispatcher servlet 앞 단에 있어 보안에 대한 체크를 위한 로직을 위해 추가
    - 인터셉터는 dispatcher servlet이 컨트롤러에 요청하기 전과 후에 실행됨.
    
    [[Spring] 필터(Filter) vs 인터셉터(Interceptor) 차이 및 용도 - (1)](https://mangkyu.tistory.com/173)
    
- schedule
- cron

---

- reflection
    
    annotation도 함께
    
- spring 레이어드 아키텍처
- 객체 종류
    - ‣

---

- 커넥션 풀, spring boot에서 커넥션 풀 뭐 사용했는지
- cache

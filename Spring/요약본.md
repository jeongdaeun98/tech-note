- DI
    - 직접 객체를 생성하여 선언하는 것이 아닌, 객체의 의존성을 주입받는다.(Store-Product: DI, 
    Store-Pencil: DIx) DI가 아닐 땐, 객체와 객체의 관계가 형성되지 않고,클래스와 클래스 간의 관계가 형성되는 단점이 있다. 이 경우, 재사용성이 낮아지고, 유지보수, 수정이 어려워지는 문제가 있다.
    - 예를 들어 핸드폰 기능을 수행하고자 한다면, 그 기능을 가진 기종을 실행시키는 클래스를 따로 따로 만들어야 해서, 생산성도 떨어지고 추후 유지보수도 어려워지는 단점이 있음.
        - 그러나 기능을 인터페이스로 클래스에 선언해두고, 그 기능을 가진 기종을 의존성 주입하면, 따로 만들지 않더라도 하나의 클래스에서 기능을 수행할 수 있고, 유지보수도 쉬워진다.
- IoC
    
    기존 자바 프로그램의 경우, 개발자가 직접 제어함.
    기존엔 클래스간의 의존성을 맺어 결합도가 높아 유지보수가 어려웠다. 또한 개방 폐쇄 원칙을 위반했다.
     클래스 내부에서 다른 객체의 메소드를 사용하고 싶다면, 클래스 내에 다른 객체 선언 후 생성. 그러나 스프링에서는 IOC 제어의 역전으로 어플리케이션 컨텍스트에서 빈 생성과 생명 주기와 설정 정보를 통한 빈 주입을 관리함. 이를 통해, 객체지향 원칙을 지키기 쉬워짐.
    
     인터페이스는 구현을 강제해서 기능에 대해 동일하게 작동하도록 표준화하여 서로 다른 객체들끼리 상호작용할 수 있도록 한다. 객체들간의 의존성을 갖고 있어, 런타임 시점에 의존성이 주입되므로, 변경에 유연한 코드를 작성할 수 있다.
    
- ApplicationContext
    - spring container의 한 종류이며, 빈 팩토리를 확장시켜 AOP등의 기능을 제공하며, 빈 주입과 생명주기를 관리한다. 또한 lazy loading으로 메서드나 클래스가 빈 요청 시에만 객체를 만들고 빈을 로드한다.
- 자바와 스프링 싱글톤
    - 자바에서는 싱글톤이 안티패턴으로 불린다. 자바에서 보편적으로, 싱글톤을 만들기 위해서는 클래스의 생성자를 private으로 만들어서 객체를 새롭게 생성할 수 없게 만든다. 그리고 의존성 주입을 해주는 메소드를 static 메소드로 만들어 전역에서 해당 클래스에 대한 의존성 주입이 가능하도록 만든다.
    - 이와 같은 단점들을 보완한 게 스프링 싱글톤이다.
    - 이 것에는 4가지 단점이 있다.
        1. private 생성자로 만들어져 상속이 어렵다.
            1. 상속은 객체 지향의 특성으로 기능의 확장을 가능하게 한다.
        2. static 메소드로 전역 메소드로 이뤄져 객체 지향의 특성 중 캡슐화를 어긴다.
            1. 캡슐화로 하나의 기능으로 집중하여 독립성을 높이고, 의존성을 낮춰 결합도를 낮추고 응집도를 높여 수정이 용이하고 재사용성이 높은 프로그래밍을 만들 수 있으나 이것을 어렵게 함.
        3. 싱글톤으로 test하기 어렵다.
        4. 서버 환경에서는 한개의 싱글톤이 보장되지 않을 수 있다.
            1. A 스레드는 의존성이 주입되지 않았다고 체크하여 새 의존성을 주입했는데, B 스레드가 A스레드의 의존성 주입 직전에 주입되지 않았음을 체크해서 새 의존성을 다시 주입하는 상황이 발생한다.
- 스프링 빈과 자바 빈
    - 자바 빈은 pojo 객체로, 객체 지향원리에 충실하게 개발되었으며 특정한 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 말한다. 스프링 빈은 application context에 의해 의존성 주입되고, 생명주기가 관리되는 자바 객체를 말한다.
- 스프링 빈 스코프
    - sigleton, prototype이 있는데, 디폴트는 singleton이다. 즉 생성된 객체는 단 한개이며, applicaton context에 의해 빈 주입을 받고, 생명주기를 관리받는다. prototype은 빈 객체 요청할 때 마다 새롭게 생성하며, 생명주기 또한 개발자가 직접 관리해야한다.

---

- 빈의 생명주기
- 스프링 빈 주입 방법
    - 생성자 주입, setter 주입, 필드 주입 등이 있는데, 생성자 주입을 사용하는 것이 좋다.
        - 순환 참조를 방지할 수 있음. 클래스 생성자를 호출하면서 그 필드에 해당하는 빈들의 의존성을 주입하는데, 이 때 순환참조가 있음을 컴파일 단계에서 알 수 있음.
        - final로 객체를 선언할 수 있어 불변성을 유지할 수 있음(Collection일 경우는 애매..)
- @Bean 과 @Component의 차이
    - 전자는 메소드 레벨에서 등록, 개발자가 수동으로 빈 등록, 후자는 클래스 레벨에서 등록, 스프링이 컴포넌트 스캔을 통해 자동으로 빈 등록

---

- @Configuration
- AOP
    - 관점지향 프로그래밍, 모든 코드에 수행되는 로깅 처리나, 성능 테스트와 같은 공통적인 로직으로 묶어서 코드의 앞/뒤에 공통 로직을 수행하도록 처리해 중복 코드를 제거하는 프로그래밍.
- spring scope

---

- proxy
- dynamic proxy

---

- Data source란?
- 트랜잭션 동기화 매니저의 역할

---

- Maven과 Gradle
    - maven은 라이브러리나 프로젝트 의존성을 pom.xml에 명시
    - gradle은 build.gradle에 라이브러리나 프로젝트 의존성을 명시하며, groovy 언어로 새겨짐.
        - 증분 빌드로, 이전에 빌드된 task의 경우 냅두고, 빌드되지 않은 task만 빌드되는 형태임.
        - build cache가 있어서, 이전에 캐시가 남아있으면 해당 캐시로 빌드 진행함.
- 필터와 인터셉터 차이
    - 필터는 dispatcher servlet 앞 단에 있어 보안에 대한 체크를 위한 로직을 위해 추가
    - 인터셉터는 dispatcher servlet이 컨트롤러에 요청하기 전과 후에 실행됨.

---

- multi thread
- async

---

- schedule
- cron

---

- reflection
    
    annotation도 함께
    
- spring 레이어드 아키텍처
- 객체 종류
    - ‣

---

- 커넥션 풀, spring boot에서 커넥션 풀 뭐 사용했는지
- cache

[[면접총정리] 신입 개발자 인터뷰 대비 총정리 자료 - ⑦ 백엔드(Java Spring 기반)](https://hoons-dev.tistory.com/97#%25F-%25-F%25--%25A-%25--Spring%25--Batch%EC%25-D%25--%25--Job%EA%25B-%BC%25--Step%EC%25-D%25--%25--%EA%25B-%AC%EC%25A-%25B-%EC%25--%25--%25--%EB%25-C%25--%ED%25--%25B-%25--%EC%25--%25A-%EB%AA%25--%ED%25--%25B-%EC%25A-%BC%EC%25--%25B-%EC%25-A%25---)

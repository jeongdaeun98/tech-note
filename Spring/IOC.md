# IOC

### 기존 자바 프로그램

 각 객체들이 프로그램의 흐름 결정, 객체를 직접 생성하여 메소드 호출

A 객체에서 B객체에 있는 메소드를 사용하고 싶다면, A 객체 내에 B 객체를 생성하고 메소드를 호출함.

```java
class A {
	B b = new B();
	b.searchName();
}
```

→즉, 모든 작업을 사용자가 제어하는 구조

> 클래스 내부에 객체 생성 → 의존성 객체의 메소드 호출
> 

but Spring에서는?

### 제어의 역전

객체의 생성을 빈 팩토리에게 맡김.

<aside>
💡 실제로는 빈의 생성과 관계설정 외에 추가적인 기능이 필요함. 
이러한 이유로 spring에서는 빈 팩토리를 상속받아 확장한 애플리케이션 컨텍스트를 주로 사용.

</aside>

사용자는 객체를 직접 생성하지 않고, 객체의 생명주기를 컨트롤하는 주체는 빈 팩토리임.

```java
class A {
	private final B b;
	@Autowired // 의존성 주입
	A (B b) {
		this.b = b;
	}
}
```

→ 즉, 사용자의 제어권을 다른 주체에게 넘기는 것을 **IOC**라 함.

> 스프링에게 제어를 위임하여 스프링이 만든 객체를 주입 →  의존성 객체의 메소드 호출
>

redis는 NoSQL로 분류되기도, 인메모리로 분류되기도 한다.

| 기능 | Redis | Memcached |
| --- | --- | --- |
| 속도 | 초당 100,000QPS 이상 | 초당 100,000QPS 이상 |
| 자료구조 | Key-Value,List, Hash, Set, Sorted Set | Key-Value |
| 안정성 | 특성을 잘못 이해할 경우 프로세스 장애 발생 | 장애 거의 없음 |
| 응답 속도의 균일성 | 균일성이 떨어질 수 있음 | 전체적으로 균일 |

redis는 global cache 방식을 채택했다.

## 사용자가 많은 트래픽에 적합한 Redis

네트워크 트래픽 발생으로 로컬 캐시보단 성능이 떨어진다.

그렇지만 사용자 증가로 인해 WAS 인스턴스가 더 붙는 경우를 가정했을 때 로컬캐시이고, 같은 데이터가 서버 곳곳에 존재한다고 가정하면,  메모리 사용량이 그만큼 늘어나므로 효율성이 없다.

 샤딩으로 분산 저장하면 네트워크 트래픽으로 인한 지연이 있겠지만 메모리 효율을 높일 수 있다. 

또한 한 서버가 CPU 사용량 증가 및 메모리 용량 부족으로 서버가 다운되는 상황에 대한 대비를 위해, 데이터 복제가 이뤄지는데, 복제차원에서 모든 서버에 같은 데이터를 넣었다 하더라도 직접 조회되지 않으나 메모리에서 차지하고 있다면 비효율적.

그러나 redis에서 마스터 서버와 slave 서버를 설정해두고, 마스터 서버는 쓰기 작업을, 슬레이브는 마스터 서버의 복제 작업을 한다. 마스터 서버가 3개가 있다하면, 데이터는 3개 중 하나에 쓰여지고, 슬레이브는 이 서버를 복제하는 방식으로 하면, 데이터를 효율적으로 활용될 수 있다.

따라서 이런 이유로 redis는 다수의 트래픽이 집중 발생하는 사용자가 많은 환경에 적합하다.

## Data 저장

데이터는 메모리에 write read가 일어나지만, server가 다운되는 상황에 데이터 저장을 보장하기 위해서 disk를 persistence store로 사용한다.

- set
    - 교집합, 합집합, 차이를 매우 빠른 시간 내에 추출할 수 있음.
- sorted set
- set에 score라는 필드가 추가된 데이터 형, 오름차순으로 내부 정렬
- score 값 범위에 따른 쿼리, top rank에 따른 쿼리 등이 가능
- hashes
- list
    - 양방향 linked list
    - list의 앞과 뒤에 데이터를 넣거나 뺄 수 있음.
    - 지정된 index 값을 이용하여 지정된 위치에 데이터를 넣거나 뺄 수 있음.

### persistence store

snapshot으로 주기적인 백업을 하고, 다음 스냅샷까지의 저장은 AOF로 수행한다. 이렇게 되면 서버가 restart할 때 백업된 스냅샷을 로드 후, 이후 시점에 이뤄진 연산은 AOF 로그를 재수행하면 되므로 restart 시간을 절약하면서 데이터 유실을 방지할 수 있다.

- snapshotting(RDB)
    - 순간적으로 메모리에 있는 내용 disk에 옮겨 담는 방식
    - 메모리에 스냅샷을 그대로 뜬 것이므로, 서버 재시작할 때 스냅샷만 로드하면 되어서 restart 시간이 빠르다.
    - 스냅샷 추출할 때 시간이 오래 걸린다.
    - 스냅샷 추출 이후 서버 다운되면, 이후 데이터는 유실된다.
    - SAVE
        - blocking방식으로 redis 모든 동작 정지
        - 그 때의 스냅샷 disk에 저장
    - BGSAVE
        - 논 블로킹 방식, 별도의 process 띄운 후, 명령어 수행 당시의 메모리 snapshot을 disk에 저장
        - 저장 순간에 redis는 동작 멈추지 않고 정상적으로 동작
        - fork해서 자식 프로세스가 메모리 데이터 disk에 저장토록 함(메인 프로세스의 PCB 복제)
          - Copy on Write로 달라지지 않는 데이터는 copy, 달라지는 데이터만 저장.
          - 만일 기존 disk 데이터에서 데이터가 모두 변한 경우, 메모리 사용량이 2배 증가할 수 있고 장애 발생의 요인이 될 수 있음.
- AOF
    - redis의 모든 연산 자체를 모두 log 파일에 기록
    - 연산 발생 시마다 매번 기록하며, 기본적으로 논블로킹이라 연산에 영향을 주지 않는다.
    - 어느 시점에 서버가 다운되더라도 데이터 유실 발생이 없다.
    - 그러나 로그 데이터 양은 RDB에 비해 매우 크며, 로그에 기록된 연산을 다시 수행하므로 restart  속도가 느리다.
